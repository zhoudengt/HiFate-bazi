# 👁️ HiFate-bazi 可观测性规范

## 一、概述

可观测性是系统运维的核心能力，包含三大支柱：日志、指标、追踪。

### 1.1 可观测性组件

| 组件 | 功能 | 位置 |
|------|------|------|
| **结构化日志** | 统一日志格式，支持追踪 | `server/observability/structured_logger.py` |
| **指标采集器** | 计数器、仪表盘、直方图 | `server/observability/metrics_collector.py` |
| **分布式追踪** | 请求追踪、性能分析 | `server/observability/tracer.py` |
| **告警管理** | 告警规则、通知 | `server/observability/alert_manager.py` |
| **可观测性 API** | 查询和管理接口 | `server/api/v1/observability.py` |

---

## 二、结构化日志

### 2.1 基本用法

```python
from server.observability.structured_logger import get_logger, configure_logging

# 配置日志（启动时调用一次）
configure_logging(
    level="INFO",
    json_output=False,  # 生产环境设为 True
    log_file="logs/app.log"
)

# 获取日志器
logger = get_logger("my_module")

# 基本日志
logger.info("处理请求", user_id=123, action="login")
logger.error("处理失败", error_code=500)

# 带计时的日志
with logger.timed("数据库查询", table="users"):
    result = db.query()

# 设置请求上下文（追踪 ID）
logger.set_context(trace_id="abc123", user_id=123)
```

### 2.2 日志格式

**文本格式（开发环境）：**
```
2025-12-11 10:30:45.123 [INFO    ] [abc12345] my_module: 处理请求 | {"user_id": 123}
```

**JSON 格式（生产环境）：**
```json
{
  "timestamp": "2025-12-11T10:30:45.123Z",
  "level": "INFO",
  "logger": "my_module",
  "message": "处理请求",
  "trace_id": "abc123",
  "service": "hifate-bazi",
  "extra": {"user_id": 123}
}
```

### 2.3 日志级别指南

| 级别 | 使用场景 | 示例 |
|------|----------|------|
| DEBUG | 详细调试信息 | 变量值、函数调用 |
| INFO | 正常操作信息 | 请求处理、任务完成 |
| WARNING | 潜在问题 | 配置缺失、性能下降 |
| ERROR | 错误但可恢复 | 请求失败、外部服务错误 |
| CRITICAL | 严重错误 | 系统崩溃、数据损坏 |

---

## 三、性能指标

### 3.1 指标类型

| 类型 | 用途 | 示例 |
|------|------|------|
| **Counter** | 只增不减的计数 | 请求数、错误数 |
| **Gauge** | 可增可减的值 | 当前连接数、内存使用 |
| **Histogram** | 值分布统计 | 请求延迟、响应大小 |

### 3.2 使用方法

```python
from server.observability.metrics_collector import get_metrics, timed, counted

metrics = get_metrics()

# 创建计数器
request_count = metrics.counter("http_requests_total", "HTTP请求总数", ["method", "path"])
request_count.inc(method="POST", path="/api/bazi")

# 创建仪表盘
active_connections = metrics.gauge("active_connections", "活跃连接数")
active_connections.inc()
active_connections.dec()

# 创建直方图
request_latency = metrics.histogram("http_request_duration_seconds", "请求延迟")
request_latency.observe(0.5, method="POST", path="/api/bazi")

# 装饰器方式
@timed("http_request_duration_seconds", method="POST")
def handle_request():
    pass

@counted("http_requests_total", method="POST")
def handle_request():
    pass
```

### 3.3 内置指标建议

| 指标名称 | 类型 | 说明 |
|---------|------|------|
| `http_requests_total` | Counter | HTTP 请求总数 |
| `http_request_duration_seconds` | Histogram | 请求延迟 |
| `http_request_errors_total` | Counter | 请求错误数 |
| `active_connections` | Gauge | 活跃连接数 |
| `db_query_duration_seconds` | Histogram | 数据库查询延迟 |
| `cache_hits_total` | Counter | 缓存命中数 |
| `cache_misses_total` | Counter | 缓存未命中数 |

---

## 四、分布式追踪

### 4.1 基本概念

- **Trace（追踪）**：一个完整请求的链路
- **Span（跨度）**：一个操作单元
- **Context（上下文）**：追踪信息传递

### 4.2 使用方法

```python
from server.observability.tracer import get_tracer, trace

tracer = get_tracer()

# 手动创建 Span
with tracer.start_span("handle_request") as span:
    span.set_tag("user_id", 123)
    span.log("开始处理")
    
    # 嵌套 Span
    with tracer.start_span("db_query") as child_span:
        result = db.query()
        child_span.set_tag("rows", len(result))

# 装饰器方式
@tracer.trace("handle_request", user_id=123)
def handle_request():
    pass

# 或使用便捷函数
@trace("handle_request")
def handle_request():
    pass
```

### 4.3 跨服务追踪

```python
# 服务 A：发送请求时传递追踪上下文
context = tracer.get_current_context()
headers = context.to_headers() if context else {}
response = requests.post(url, headers=headers)

# 服务 B：接收请求时解析追踪上下文
from server.observability.tracer import TraceContext

context = TraceContext.from_headers(request.headers)
if context:
    tracer.set_context(context)
```

---

## 五、监控告警

### 5.1 告警严重程度

| 级别 | 说明 | 响应时间 |
|------|------|----------|
| INFO | 信息通知 | 无需响应 |
| WARNING | 需要关注 | 工作时间内 |
| ERROR | 需要处理 | 4小时内 |
| CRITICAL | 紧急处理 | 15分钟内 |

### 5.2 使用方法

```python
from server.observability.alert_manager import (
    get_alert_manager, Alert, AlertSeverity, AlertRule
)

alert_manager = get_alert_manager()

# 添加告警规则
alert_manager.add_rule(AlertRule(
    name="high_error_rate",
    condition=lambda: get_error_rate() > 0.1,
    severity=AlertSeverity.ERROR,
    message="错误率超过 10%",
    for_duration=60  # 持续 60 秒才触发
))

# 手动触发告警
alert_manager.fire(Alert(
    name="service_down",
    severity=AlertSeverity.CRITICAL,
    message="bazi-core 服务不可用"
))

# 解除告警
alert_manager.resolve("service_down")

# 启动自动检查
alert_manager.start(check_interval=30)
```

### 5.3 告警规则建议

| 告警名称 | 条件 | 严重程度 |
|---------|------|----------|
| 高错误率 | 错误率 > 10% | ERROR |
| 服务不可用 | 健康检查失败 | CRITICAL |
| 响应时间过长 | P95 > 2秒 | WARNING |
| 内存使用过高 | > 90% | WARNING |
| 磁盘空间不足 | < 10% | ERROR |

---

## 六、可观测性 API

### 6.1 API 列表

| 路径 | 方法 | 说明 |
|------|------|------|
| `/api/v1/observability/metrics` | GET | 获取所有指标 |
| `/api/v1/observability/metrics/prometheus` | GET | Prometheus 格式指标 |
| `/api/v1/observability/traces` | GET | 获取追踪数据 |
| `/api/v1/observability/traces/stats` | GET | 追踪统计 |
| `/api/v1/observability/alerts` | GET | 获取活跃告警 |
| `/api/v1/observability/alerts/history` | GET | 告警历史 |
| `/api/v1/observability/alerts/fire` | POST | 触发告警 |
| `/api/v1/observability/alerts/{name}/resolve` | POST | 解除告警 |
| `/api/v1/observability/dashboard` | GET | 仪表板数据 |
| `/health` | GET | 健康检查 |
| `/health/live` | GET | 存活检查 |
| `/health/ready` | GET | 就绪检查 |

### 6.2 使用示例

```bash
# 获取指标
curl http://localhost:8001/api/v1/observability/metrics

# Prometheus 格式
curl http://localhost:8001/api/v1/observability/metrics/prometheus

# 获取追踪
curl http://localhost:8001/api/v1/observability/traces?limit=10

# 获取告警
curl http://localhost:8001/api/v1/observability/alerts

# 触发告警
curl -X POST http://localhost:8001/api/v1/observability/alerts/fire \
  -H "Content-Type: application/json" \
  -d '{"name": "test_alert", "severity": "warning", "message": "测试告警"}'

# 仪表板
curl http://localhost:8001/api/v1/observability/dashboard
```

---

## 七、最佳实践

### 7.1 日志最佳实践

1. **使用结构化日志**：便于搜索和分析
2. **包含追踪 ID**：便于关联请求
3. **控制日志量**：避免 DEBUG 级别过多
4. **不记录敏感信息**：密码、密钥等

### 7.2 指标最佳实践

1. **使用有意义的名称**：`http_requests_total` 而非 `count`
2. **添加标签**：`method`, `path`, `status`
3. **限制基数**：避免标签值过多
4. **设置合理的桶**：直方图桶要覆盖实际分布

### 7.3 追踪最佳实践

1. **追踪关键路径**：不追踪所有操作
2. **合理设置标签**：关键信息如 user_id
3. **跨服务传递上下文**：通过 HTTP 头
4. **限制 Span 数量**：避免过深嵌套

### 7.4 告警最佳实践

1. **设置合理阈值**：避免误报
2. **设置持续时间**：避免瞬时触发
3. **分级处理**：按严重程度响应
4. **定期审查规则**：删除无用告警

---

## 八、集成指南

### 8.1 FastAPI 中间件集成

```python
from fastapi import FastAPI, Request
from server.observability import get_logger, get_metrics, get_tracer

app = FastAPI()
logger = get_logger("api")
metrics = get_metrics()
tracer = get_tracer()

# 指标
request_count = metrics.counter("http_requests_total", labels=["method", "path", "status"])
request_latency = metrics.histogram("http_request_duration_seconds", labels=["method", "path"])

@app.middleware("http")
async def observability_middleware(request: Request, call_next):
    # 开始追踪
    with tracer.start_span(f"{request.method} {request.url.path}") as span:
        # 设置日志上下文
        logger.set_context(trace_id=span.context.trace_id)
        
        start_time = time.time()
        try:
            response = await call_next(request)
            status = response.status_code
        except Exception as e:
            status = 500
            span.span.status = SpanStatus.ERROR
            raise
        finally:
            duration = time.time() - start_time
            
            # 记录指标
            request_count.inc(method=request.method, path=request.url.path, status=str(status))
            request_latency.observe(duration, method=request.method, path=request.url.path)
            
            # 记录日志
            logger.info(
                f"{request.method} {request.url.path}",
                status=status,
                duration_ms=duration * 1000
            )
        
        return response
```

### 8.2 Prometheus 集成

```yaml
# prometheus.yml
scrape_configs:
  - job_name: 'hifate-bazi'
    static_configs:
      - targets: ['localhost:8001']
    metrics_path: '/api/v1/observability/metrics/prometheus'
    scrape_interval: 15s
```

### 8.3 Kubernetes 健康检查

```yaml
# deployment.yaml
spec:
  containers:
    - name: hifate-bazi
      livenessProbe:
        httpGet:
          path: /health/live
          port: 8001
        initialDelaySeconds: 30
        periodSeconds: 10
      readinessProbe:
        httpGet:
          path: /health/ready
          port: 8001
        initialDelaySeconds: 5
        periodSeconds: 5
```

---

## 九、故障排查

### 9.1 日志查询

```bash
# 搜索错误日志
grep "ERROR" logs/app.log

# 按追踪 ID 搜索
grep "trace_id.*abc123" logs/app.log

# 按时间范围搜索
grep "2025-12-11T10" logs/app.log
```

### 9.2 指标分析

```bash
# 查看请求指标
curl http://localhost:8001/api/v1/observability/metrics | jq '.data.histograms'

# 查看错误率
# error_rate = http_request_errors_total / http_requests_total
```

### 9.3 追踪分析

```bash
# 获取慢请求追踪
curl "http://localhost:8001/api/v1/observability/traces?limit=100" | \
  jq '[.data.traces[] | select(.duration_ms > 1000)]'
```

---

## 十、版本历史

| 版本 | 日期 | 说明 |
|------|------|------|
| 1.0.0 | 2025-12-11 | 初始版本 |
