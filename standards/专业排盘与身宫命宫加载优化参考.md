# 专业排盘与身宫命宫加载优化参考

本文档记录「基本排盘 → 专业排盘 / 胎命身」路径的优化方案与实现，供后期同类优化参考。

---

## 一、场景与目标

| 项目 | 说明 |
|------|------|
| **前端路径** | 用户先进入「基本排盘」，再切换「专业排盘」或「胎命身」tab |
| **涉及接口** | `/bazi/pan/display`（基本排盘）、`/bazi/fortune/display`（专业排盘-大运流年流月）、`/bazi/shengong-minggong`（专业排盘-身宫命宫胎元） |
| **优化目标** | 基本排盘返回后，用户切到专业排盘或胎命身时**秒出**（命中预热缓存），避免重复计算 |

---

## 二、问题与根因

### 2.1 现象

- 首次进入专业排盘或胎命身：~1.5s
- 切换大运时：~1.2s
- 同一天内重复访问同一人：仍较慢（缓存未生效）

### 2.2 根因

1. **detail 缓存 key 含秒级 current_time**  
   `BaziDetailService.calculate_detail_full` 的 cache key 使用 `current_time.isoformat()`，每秒不同，30 天 TTL 形同虚设，每次都重算。

2. **bazi 无 service 层缓存**  
   `BaziService.calculate_bazi_full` 无缓存，每次调用都重算八字四柱（~0.3s）。

3. **跨 tab 无数据共享**  
   基本排盘、专业排盘、身宫命宫胎元使用不同编排模块配置，且 service 层缓存失效，导致同一人的数据被重复计算。

---

## 三、优化方案概览

| 措施 | 说明 | 涉及文件 |
|------|------|----------|
| **Fix1：detail 缓存 key 改为日期级** | `current_time` 在 key 中从秒级改为 `%Y-%m-%d`，同天同人复用 | `server/services/bazi_detail_service.py` |
| **Fix2：bazi 增加 L1+L2 缓存** | `calculate_bazi_full` 入口查缓存、出口写缓存，key 为 `bazi_full:{solar_date}:{solar_time}:{gender}`，TTL 24h | `server/services/bazi_service.py` |
| **Fix3：pan 返回后后台预热** | `get_pan_display` 成功返回后，异步预取 `fortune_display` 与 `shengong_minggong` 所需数据，仅预热 service 层缓存 | `server/api/v1/bazi_display.py` |

---

## 四、实现要点

### 4.1 Fix1：detail 缓存 key 日期级

- **位置**：`server/services/bazi_detail_service.py`，生成 cache_key_parts 处。
- **修改**：  
  `current_time_iso = current_time.isoformat() if current_time else None`  
  →  
  `current_time_iso = current_time.strftime('%Y-%m-%d') if current_time else 'default'`
- **安全性**：`quick_mode=True` 时仅计算大运/流年（按年/十年变），日期级粒度足够；liuri/liushi 不在此模式计算。

### 4.2 Fix2：bazi 的 L1+L2 缓存

- **位置**：`server/services/bazi_service.py` 的 `calculate_bazi_full`。
- **key**：`bazi_full:{solar_date}:{solar_time}:{gender}`（八字仅与出生时间相关，不含 current_time）。
- **TTL**：86400 秒（24 小时），与 API 层 L2 一致。
- **缓存组件**：使用 `server.utils.cache_multi_level.get_multi_cache()`，与项目其他 service 一致。

### 4.3 Fix3：pan 返回后预热 fortune_display + shengong_minggong

- **位置**：`server/api/v1/bazi_display.py` 的 `get_pan_display`，在 `set_cached_result` 之后、`return result` 之前。
- **方式**：  
  - `asyncio.ensure_future(_prefetch_fortune_display(...))`  
  - `asyncio.ensure_future(_prefetch_shengong_minggong(...))`  
  使用与当前请求相同的 `final_solar_date, final_solar_time, gender, calendar_type, location, latitude, longitude`。
- **预取逻辑**：  
  - `_prefetch_fortune_display`：`get_modules_config('fortune_display')` + `BaziDataOrchestrator.fetch_data(..., current_time=datetime.now())`  
  - `_prefetch_shengong_minggong`：`get_modules_config('shengong_minggong')` + 同上  
  不写 API 层缓存，只触发编排器拉取 bazi/detail/interface 等，从而写满 service 层缓存。
- **注意**：仅在实际计算成功返回时触发预热（走缓存命中路径时不触发，避免无意义预取）。

---

## 五、数据流与缓存层次

```
用户请求
  → API 层（如 gRPC / REST）
  → BaziDataOrchestrator.fetch_data(modules=fortune_display 或 shengong_minggong)
  → 并行：BaziService.calculate_bazi_full [Fix2 缓存]
         BaziDetailService.calculate_detail_full [Fix1 缓存]
         （shengong_minggong 还有 BaziInterfaceService.generate_interface_full）
  → 编排器组装
  → API 层组装响应（REST/gRPC 另有 L1+L2 API 缓存）

基本排盘返回后：
  → ensure_future(_prefetch_fortune_display) + ensure_future(_prefetch_shengong_minggong)
  → 后台执行上述 fetch_data，写满 bazi / detail（及 interface）的 service 层缓存
  → 用户再点「专业排盘」或「胎命身」时，同一人的 bazi、detail 命中缓存，秒出
```

---

## 六、预期效果与验证

| 场景 | 优化前 | 优化后 |
|------|--------|--------|
| 基本排盘 → 专业排盘 | ~1.5s | **~0.1s**（预热 + service 缓存） |
| 基本排盘 → 胎命身 | ~1.5s | **~0.1s**（同上） |
| 直接进入专业排盘/胎命身（首次） | ~1.5s | ~1.0s（bazi/detail 仍可能未命中） |
| 同一天再次访问同一人 | 慢 | 快（detail 按日缓存） |
| 切换大运 | ~1.2s | ~0.3s（detail 缓存命中） |

**建议验证步骤**：  
1. 打开基本排盘，等待 2～3 秒。  
2. 切换到专业排盘或胎命身，观察首屏时间（应明显变快）。  
3. 同一天内对同一八字重复打开专业排盘/胎命身，观察二次访问延迟。

---

## 七、相关规范与代码

- 数据编排统一入口：`standards/08_数据编排架构规范.md`
- 编排模块配置：`server/orchestrators/modules_config.py`（`fortune_display`、`shengong_minggong`）
- 预热与组装：`server/api/v1/bazi_display.py`（`_prefetch_fortune_display`、`_prefetch_shengong_minggong`、`_assemble_fortune_display_response`、`_assemble_shengong_minggong_response`）
- 多级缓存：`server/utils/cache_multi_level.py`、`server/utils/api_cache_helper.py`

---

## 八、后续可优化方向

- 若「直接进入专业排盘/胎命身」仍偏慢，可考虑：入口页或路由层在适当时机触发一次 `pan_display` 或直接预取 `fortune_display`/`shengong_minggong`（需与前端协作）。  
- 若 `BaziInterfaceService.generate_interface_full` 成为瓶颈，可评估为其增加 service 层缓存（key 与 bazi 类似，仅出生时间相关）。
