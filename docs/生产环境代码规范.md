# 生产环境代码规范

## 📋 目录

1. [代码质量要求](#1-代码质量要求)
2. [错误处理规范](#2-错误处理规范)
3. [日志记录规范](#3-日志记录规范)
4. [性能优化规范](#4-性能优化规范)
5. [安全规范](#5-安全规范)
6. [测试要求](#6-测试要求)
7. [文档要求](#7-文档要求)
8. [代码审查清单](#8-代码审查清单)

---

## 1. 代码质量要求

### 1.1 语法和风格

#### ✅ 必须遵守

1. **Python 版本**：Python 3.11+
2. **代码风格**：遵循 PEP 8
3. **类型提示**：推荐使用类型提示
4. **文档字符串**：所有公共函数必须有 docstring

#### 代码检查工具

```bash
# 代码格式化
black .

# 代码检查
flake8 .

# 类型检查
mypy .

# 代码复杂度检查
radon cc . --min B
```

### 1.2 代码组织

#### 文件结构

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
模块说明
"""

# 标准库导入
import os
import sys
from typing import Optional, List

# 第三方库导入
import fastapi
from pydantic import BaseModel

# 本地导入
from server.services import SomeService

# 常量定义
DEFAULT_TIMEOUT = 30

# 类定义
class MyClass:
    """类说明"""
    pass

# 函数定义
def my_function():
    """函数说明"""
    pass

# 主程序
if __name__ == "__main__":
    pass
```

---

## 2. 错误处理规范

### 2.1 异常处理原则

#### ✅ 必须遵守

1. **捕获具体异常**：不要使用裸露的 `except:`
2. **记录异常信息**：使用 `exc_info=True` 记录堆栈
3. **重新抛出或返回**：根据业务逻辑决定
4. **提供用户友好消息**：不要暴露内部错误

#### 错误处理模板

```python
import logging

logger = logging.getLogger(__name__)

def process_data(data: dict) -> dict:
    """
    处理数据
    
    Args:
        data: 输入数据
        
    Returns:
        处理后的数据
        
    Raises:
        ValueError: 数据格式错误
        ConnectionError: 连接失败
    """
    try:
        # 验证输入
        if not data:
            raise ValueError("数据不能为空")
        
        # 业务逻辑
        result = do_work(data)
        
        return result
        
    except ValueError as e:
        # 业务逻辑错误，记录并重新抛出
        logger.warning(f"数据验证失败: {e}", extra={'data': data})
        raise
        
    except ConnectionError as e:
        # 连接错误，记录并重新抛出
        logger.error(f"连接失败: {e}", exc_info=True)
        raise
        
    except Exception as e:
        # 未知错误，记录并重新抛出
        logger.critical(f"未知错误: {e}", exc_info=True, extra={'data': data})
        raise
```

### 2.2 错误分类

| 错误类型 | 处理方式 | 日志级别 |
|---------|---------|---------|
| **业务逻辑错误** | 返回错误信息 | WARNING |
| **参数错误** | 返回 400 错误 | WARNING |
| **权限错误** | 返回 403 错误 | WARNING |
| **资源不存在** | 返回 404 错误 | INFO |
| **服务错误** | 返回 500 错误 | ERROR |
| **系统错误** | 返回 500 错误 | CRITICAL |

---

## 3. 日志记录规范

### 3.1 日志级别

| 级别 | 使用场景 | 示例 |
|------|---------|------|
| **DEBUG** | 调试信息 | 函数参数、中间结果 |
| **INFO** | 正常操作 | 请求处理、状态变化 |
| **WARNING** | 警告信息 | 参数验证失败、降级操作 |
| **ERROR** | 错误信息 | 异常捕获、操作失败 |
| **CRITICAL** | 严重错误 | 系统崩溃、数据丢失 |

### 3.2 日志格式

#### 结构化日志

```python
import logging

logger = logging.getLogger(__name__)

# ✅ 正确：使用结构化日志
logger.info("处理请求", extra={
    'request_id': request.id,
    'user_id': request.user_id,
    'action': 'process',
    'duration': 0.123
})

# ❌ 错误：字符串拼接
logger.info(f"处理请求 {request.id} for user {request.user_id}")
```

#### 日志配置

```python
# logging_config.py
import logging
from logging.handlers import RotatingFileHandler

def setup_logging():
    """配置日志"""
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s - %(extra)s'
    )
    
    # 文件处理器
    file_handler = RotatingFileHandler(
        'logs/app.log',
        maxBytes=10*1024*1024,  # 10MB
        backupCount=5
    )
    file_handler.setFormatter(formatter)
    file_handler.setLevel(logging.INFO)
    
    # 控制台处理器
    console_handler = logging.StreamHandler()
    console_handler.setFormatter(formatter)
    console_handler.setLevel(logging.WARNING)
    
    # 根日志器
    root_logger = logging.getLogger()
    root_logger.setLevel(logging.INFO)
    root_logger.addHandler(file_handler)
    root_logger.addHandler(console_handler)
```

### 3.3 敏感信息处理

#### ✅ 必须遵守

1. **密码**：永远不记录密码
2. **Token**：只记录 Token 的前几位
3. **身份证号**：脱敏处理（只显示后4位）
4. **银行卡号**：脱敏处理（只显示后4位）

#### 脱敏示例

```python
def mask_sensitive_data(data: str, keep_last: int = 4) -> str:
    """脱敏处理"""
    if len(data) <= keep_last:
        return '*' * len(data)
    return '*' * (len(data) - keep_last) + data[-keep_last:]

# 使用示例
logger.info("用户登录", extra={
    'user_id': user_id,
    'token': mask_sensitive_data(token, keep_last=8)  # 只显示后8位
})
```

---

## 4. 性能优化规范

### 4.1 性能要求

| 指标 | 要求 | 说明 |
|------|------|------|
| **API 响应时间** | < 500ms (P95) | 95% 的请求在 500ms 内完成 |
| **数据库查询** | < 100ms | 单次查询时间 |
| **缓存命中率** | > 90% | 缓存使用效率 |
| **内存使用** | < 2GB | 单服务实例 |
| **CPU 使用** | < 70% | 正常负载下 |

### 4.2 性能监控

#### 性能装饰器

```python
import time
import logging
from functools import wraps

logger = logging.getLogger(__name__)

def monitor_performance(threshold: float = 1.0):
    """
    性能监控装饰器
    
    Args:
        threshold: 性能阈值（秒），超过此值记录警告
    """
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            start = time.time()
            try:
                result = func(*args, **kwargs)
                duration = time.time() - start
                
                if duration > threshold:
                    logger.warning(
                        f"函数 {func.__name__} 执行缓慢",
                        extra={
                            'function': func.__name__,
                            'duration': duration,
                            'threshold': threshold
                        }
                    )
                else:
                    logger.debug(
                        f"函数 {func.__name__} 执行完成",
                        extra={
                            'function': func.__name__,
                            'duration': duration
                        }
                    )
                
                return result
            except Exception as e:
                duration = time.time() - start
                logger.error(
                    f"函数 {func.__name__} 执行失败",
                    extra={
                        'function': func.__name__,
                        'duration': duration,
                        'error': str(e)
                    },
                    exc_info=True
                )
                raise
        return wrapper
    return decorator

# 使用示例
@monitor_performance(threshold=0.5)
def process_data(data):
    # 业务逻辑
    pass
```

### 4.3 缓存使用

#### ✅ 必须遵守

1. **缓存键设计**：使用有意义的键名
2. **缓存过期**：设置合理的过期时间
3. **缓存更新**：数据变化时更新缓存
4. **缓存穿透**：防止缓存穿透攻击

#### 缓存示例

```python
from functools import lru_cache
import redis

redis_client = redis.Redis(host='localhost', port=6379)

def get_user_data(user_id: int, use_cache: bool = True) -> dict:
    """
    获取用户数据（带缓存）
    
    Args:
        user_id: 用户ID
        use_cache: 是否使用缓存
        
    Returns:
        用户数据
    """
    cache_key = f"user:{user_id}"
    
    # 尝试从缓存获取
    if use_cache:
        cached_data = redis_client.get(cache_key)
        if cached_data:
            return json.loads(cached_data)
    
    # 从数据库获取
    user_data = db.get_user(user_id)
    
    # 写入缓存（过期时间 1 小时）
    if use_cache and user_data:
        redis_client.setex(
            cache_key,
            3600,  # 1小时
            json.dumps(user_data)
        )
    
    return user_data
```

---

## 5. 安全规范

### 5.1 输入验证

#### ✅ 必须遵守

1. **使用 Pydantic**：所有 API 输入使用 Pydantic 验证
2. **参数类型检查**：验证参数类型和范围
3. **SQL 注入防护**：使用参数化查询
4. **XSS 防护**：输出转义

#### 输入验证示例

```python
from pydantic import BaseModel, Field, validator
from typing import Optional

class UserRequest(BaseModel):
    """用户请求模型"""
    username: str = Field(..., min_length=3, max_length=20, regex="^[a-zA-Z0-9_]+$")
    email: str = Field(..., regex="^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$")
    age: int = Field(..., ge=0, le=150)
    
    @validator('username')
    def validate_username(cls, v):
        if 'admin' in v.lower():
            raise ValueError('用户名不能包含 admin')
        return v
```

### 5.2 认证授权

#### ✅ 必须遵守

1. **JWT Token**：使用 JWT 进行认证
2. **Token 过期**：设置合理的过期时间
3. **权限检查**：每个接口都要检查权限
4. **密码加密**：使用 bcrypt 加密密码

#### 认证示例

```python
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials

security = HTTPBearer()

async def verify_token(credentials: HTTPAuthorizationCredentials = Depends(security)):
    """验证 Token"""
    token = credentials.credentials
    
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=["HS256"])
        user_id = payload.get("user_id")
        if user_id is None:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="无效的 Token"
            )
        return user_id
    except jwt.ExpiredSignatureError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Token 已过期"
        )
    except jwt.InvalidTokenError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="无效的 Token"
        )

@router.get("/protected")
async def protected_route(user_id: int = Depends(verify_token)):
    """受保护的路由"""
    return {"user_id": user_id}
```

---

## 6. 测试要求

### 6.1 测试覆盖率

| 类型 | 覆盖率要求 | 说明 |
|------|-----------|------|
| **单元测试** | > 80% | 核心业务逻辑 |
| **集成测试** | > 60% | API 接口 |
| **端到端测试** | > 40% | 关键流程 |

### 6.2 测试规范

#### 测试文件组织

```
tests/
├── unit/              # 单元测试
│   ├── test_services/
│   └── test_utils/
├── integration/       # 集成测试
│   ├── test_api/
│   └── test_grpc/
└── e2e/               # 端到端测试
    └── test_flows/
```

#### 测试示例

```python
import pytest
from unittest.mock import Mock, patch

def test_process_data_success():
    """测试成功场景"""
    data = {"key": "value"}
    result = process_data(data)
    assert result["status"] == "success"

def test_process_data_validation_error():
    """测试验证错误"""
    data = {}
    with pytest.raises(ValueError, match="数据不能为空"):
        process_data(data)

@patch('module.external_service')
def test_process_data_with_mock(mock_service):
    """测试使用 Mock"""
    mock_service.return_value = {"result": "ok"}
    data = {"key": "value"}
    result = process_data(data)
    assert result["status"] == "success"
```

---

## 7. 文档要求

### 7.1 代码文档

#### ✅ 必须遵守

1. **模块文档**：每个模块都要有文档字符串
2. **函数文档**：所有公共函数都要有 docstring
3. **参数说明**：说明所有参数的类型和含义
4. **返回值说明**：说明返回值的类型和含义
5. **异常说明**：说明可能抛出的异常

#### 文档示例

```python
def calculate_bazi(
    solar_date: str,
    solar_time: str,
    gender: str
) -> Dict[str, Any]:
    """
    计算八字排盘
    
    Args:
        solar_date: 阳历日期，格式：YYYY-MM-DD
        solar_time: 出生时间，格式：HH:MM
        gender: 性别，male 或 female
        
    Returns:
        包含八字信息的字典：
        {
            'bazi_pillars': {...},
            'deities': [...],
            'ten_gods': {...}
        }
        
    Raises:
        ValueError: 日期或时间格式错误
        CalculationError: 计算失败
        
    Example:
        >>> result = calculate_bazi("1990-01-01", "12:00", "male")
        >>> print(result['bazi_pillars']['year'])
        '庚午'
    """
    pass
```

---

## 8. 代码审查清单

### 8.1 功能审查

- [ ] 功能实现正确
- [ ] 边界情况处理
- [ ] 错误处理完整
- [ ] 性能满足要求

### 8.2 代码质量审查

- [ ] 代码风格符合 PEP 8
- [ ] 类型提示完整
- [ ] 文档字符串完整
- [ ] 代码复杂度合理

### 8.3 安全审查

- [ ] 输入验证完整
- [ ] SQL 注入防护
- [ ] XSS 防护
- [ ] 敏感信息不记录日志

### 8.4 测试审查

- [ ] 单元测试覆盖
- [ ] 集成测试覆盖
- [ ] 测试用例充分
- [ ] 测试通过

---

**文档版本**: v1.0  
**最后更新**: 2025-01-XX  
**维护者**: 开发团队

