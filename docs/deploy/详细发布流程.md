# 详细发布流程文档

## 完整工程化流程

```
本地开发 → 热更新验证 → 功能测试 → Git 提交 → 增量部署 → 生产功能验证
```

**每一步都不可跳过。跳过任何步骤都可能导致生产事故。**

---

## 第一步：本地开发

修改代码前先阅读相关规范：
- 数据编排：`standards/08_数据编排架构规范.md`
- 热更新：`standards/hot-reload.md`
- 支付相关：`standards/payment.md`

### 代码修改原则
- 禁止修改底层计算逻辑（`core/calculators/`、`server/engines/`），必须先告知用户
- 只加不删，保持向后兼容
- 新增 API 端点必须在 `server/api/grpc_gateway.py` 注册

---

## 第二步：本地热更新验证（如有本地服务）

如果本地运行了开发服务（`localhost:8001`），修改代码后触发热更新：

```bash
# 触发全量热更新（通知所有 Worker）
python3 scripts/ai/auto_hot_reload.py --trigger

# 验证热更新状态
python3 scripts/ai/auto_hot_reload.py --verify
```

**注意**：`auto_hot_reload.py` 调用 `/hot-reload/reload-all`（全量重载 + 通知所有 Worker），不是 `/hot-reload/check`（仅单 Worker）。

---

## 第三步：功能测试

根据修改范围选择测试项，**必须在提交前验证**：

### 基础接口测试

```bash
# 健康检查
curl -s http://localhost:8001/api/v1/health
# 期望：{"status":"ok"}

# 热更新功能验证（检查支付客户端、gRPC端点、数据库连接）
curl -s -X POST http://localhost:8001/api/v1/hot-reload/verify
# 期望：{"success":true, "checks":{...}} 所有 checks.*.ok 为 true
```

### 流式接口测试（TTFB < 100ms）

```bash
# 每日运势
curl -s -w "\nTTFB: %{time_starttransfer}s\n" --max-time 60 \
  -X POST http://localhost:8001/api/v1/daily-fortune-calendar/stream \
  -H "Content-Type: application/json" \
  -d '{"date":"2025-02-05","solar_date":"1992-01-15","solar_time":"12:00","gender":"male"}' \
  -o /dev/null

# 五行占比
curl -s -w "\nTTFB: %{time_starttransfer}s\n" --max-time 60 \
  -X POST http://localhost:8001/api/v1/bazi/wuxing-proportion/stream \
  -H "Content-Type: application/json" \
  -d '{"solar_date":"1992-01-15","solar_time":"12:00","gender":"male"}' \
  -o /dev/null
```

### 支付相关测试（如修改了支付模块）

```bash
# 支付渠道状态
curl -s --max-time 30 http://localhost:8001/api/v1/payment/providers
# 期望：{"success":true, "providers":[...]} 包含 stripe 和 payermax
```

### 完整回归测试（基本+流式+面相/风水流式+两种支付）

用户说「测试」即指运行以下全部接口：

```bash
# 基本接口 + 流式接口（含面相、办公桌风水）+ 支付（Stripe + PayerMax）
python3 scripts/evaluation/api_regression_test.py --env production --category basic --category stream --category payment --parallel
```

覆盖：基本 5 个、流式 13 个（含面相分析流式、办公桌风水流式）、支付 3 个（渠道状态、Stripe 创建订单、PayerMax 创建订单）。

---

## 第四步：Git 提交

```bash
git add <修改的文件>
git commit -m "<type>: <简要描述>"
git push origin master
```

**commit type 规范**：
- `feat`: 新功能
- `fix`: 修复 bug
- `refactor`: 重构（不改变功能）
- `perf`: 性能优化
- `docs`: 文档变更
- `chore`: 构建/工具变更

---

## 第五步：增量部署

### 推荐方式：门控发布（Node2 前哨验证 → Node1 部署）

**门控发布脚本会自动先在 Node2（前哨节点）部署并跑全量测试，测试通过后才部署到 Node1（生产节点）：**

```bash
# 标准门控发布（推荐）
bash deploy/scripts/gated_deploy.sh

# 只部署 Node2 跑测试，不动 Node1（验证变更安全性）
bash deploy/scripts/gated_deploy.sh --dry-run

# 紧急修复：跳过 Node2 直接部署 Node1（慎用）
bash deploy/scripts/gated_deploy.sh --skip-node2

# 只跑 Node2 回归测试（不部署代码）
bash deploy/scripts/gated_deploy.sh --test-only

# 回滚 Node1 到上一次成功的版本
bash deploy/scripts/gated_deploy.sh --rollback
```

门控发布流程：Node2 git pull → Node2 热更新 → Node2 全量测试 → **门控判断** → Node1 git pull → Node1 热更新 → Node1 验证。
任何一步失败都会停止，Node1 不受影响。部署历史记录在 `deploy/logs/`。

### 手动方式（AI 模型快速部署）

如果不使用门控脚本，AI 模型统一使用以下 3 条命令部署：

```bash
# 步骤 1：服务器拉取代码
ssh hifate-node1 "cd /opt/HiFate-bazi && git pull origin master"

# 步骤 2：触发全量热更新（必须用 reload-all，不要用 check）
curl -s --max-time 60 -X POST http://8.210.52.217:8001/api/v1/hot-reload/reload-all
# 期望：{"success":true, "reloaded_modules":[...], "message":"...已通知所有 Worker..."}

# 步骤 3：等待 Worker 同步后，再触发第二次热更新确保所有模块完全刷新
sleep 5
curl -s --max-time 60 -X POST http://8.210.52.217:8001/api/v1/hot-reload/reload-all
# 期望：{"success":true, ...} 第二次确保所有 Worker 引用更新
sleep 3
```

**为什么要两次热更新？** 单次 reload-all 可能存在 Worker 间模块引用未完全刷新的情况（尤其是跨模块函数签名变更），第二次 reload 确保所有 Worker 引用最新代码。这是生产验证过的安全做法。

> **注意**：`deploy/scripts/incremental_deploy_production.sh` 脚本需要环境变量，仅适用于 CI/CD 流水线。

### 热更新端点选择（重要！）

| 端点 | 用途 | 是否通知所有 Worker |
|------|------|-------------------|
| `/hot-reload/reload-all` | **生产部署必须用这个** | 是 |
| `/hot-reload/verify` | 部署后功能验证 | N/A（只读） |
| `/hot-reload/history` | 查看热更新历史 | N/A（只读） |
| `/hot-reload/check` | 仅开发调试用 | 否（只影响单个 Worker） |
| `/hot-reload/sync` | 双机集群同步 | 通过 Redis 通知所有节点 |

---

## 第六步：生产功能验证

**部署后必须验证，不验证等于没部署。**

### 快速验证（必做）

```bash
# 1. 健康检查
curl -s http://8.210.52.217:8001/api/v1/health
# 期望：{"status":"ok"}
```

### 全接口回归测试（必做）

```bash
# 2. 运行全接口测试（23个接口：基本5 + 流式13 + 支付5）
python3 scripts/evaluation/api_regression_test.py --env production --category basic --category stream --category payment --parallel
# 期望：通过率 100%
```

### 验证不通过的处理

如果回归测试有接口失败（尤其是 `unexpected keyword argument` 类错误）：

1. **再触发一次热更新**（模块引用可能未完全刷新）：
   ```bash
   curl -s --max-time 60 -X POST http://8.210.52.217:8001/api/v1/hot-reload/reload-all
   sleep 5
   ```
2. **重新运行测试**，确认修复
3. 如果连续 3 次热更新后仍然失败：检查服务器日志
   ```bash
   ssh hifate-node1 "docker logs hifate-web --since=5m 2>&1 | tail -50"
   ```
4. 如果是 `payment_clients` 失败：`curl -X POST http://8.210.52.217:8001/api/v1/hot-reload/reload-all`
5. 如果多次重试仍然失败且日志无明显错误：作为最后手段，联系用户确认是否需要容器级别的处理

---

## 绝对禁止的操作

- **禁止** 直接在服务器上修改代码（必须：本地 → Git → 服务器 pull）
- **禁止** 跳过 Git 提交直接部署
- **禁止** 重启服务（`docker restart`、`docker-compose restart`），必须用热更新
- **禁止** 使用 `/hot-reload/check` 做生产部署（只影响单个 Worker）
- **禁止** 跳过功能验证（`/hot-reload/verify`）就认为部署成功
- **禁止** 修改底层计算逻辑不告知用户
- **禁止** 在支付代码中使用 `del sys.modules`（会导致竞态条件）

---

## 热更新重载顺序（了解即可）

```
config(1) → rules(2) → content(3) → source(4) → singleton(5) → microservice(6) → cache(7)
```

**关键点**：singleton（重置单例缓存）在 source（重新加载代码）之后，确保新代码先注册组件，再清理旧缓存。如果顺序反了，热更新窗口期支付等功能会中断。

---

## 流式接口首包优化原则

- 走统一编排 `BaziDataOrchestrator.fetch_data()`（两阶段并行，信号量24）
- 基本信息秒出（TTFB < 100ms）
- 耗时操作放入并行任务或线程池
- LLM 调用在首包之后
- 编排层阶段1超时15s、阶段2超时10s，超时降级不阻塞
- 编排层调试日志使用 `logger.debug`，生产环境不输出
