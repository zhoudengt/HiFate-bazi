# 微服务重启错误排查总结

## 📋 问题描述

### 错误现象

重启服务后，访问**今日运势**和**当月运势**功能时出现错误：

```
AttributeError: 'str' object has no attribute 'get'
```

### 错误位置

- `server/services/daily_fortune_service.py`, line 217
- `server/services/monthly_fortune_service.py`, line 387

### 错误堆栈

```python
day_element = bazi_data.get('elements', {}).get('day', {}).get('stem_element', '未知')
AttributeError: 'str' object has no attribute 'get'
```

## 🔍 问题原因分析

### 根本原因

`bazi_data` 预期应该是一个字典类型 `Dict[str, Any]`，但实际传入的是字符串类型 `str`。

### 为什么会发生？

1. **数据流向问题**
   - `BaziService.calculate_bazi_full()` 返回的数据结构：
     ```python
     {
         "bazi": {...},      # 这才是八字数据字典
         "rizhu": "...",
         "matched_rules": []
     }
     ```
   
   - 在 `DailyFortuneService.calculate_daily_fortune()` 中正确提取：
     ```python
     bazi_result = BaziService.calculate_bazi_full(solar_date, solar_time, gender)
     bazi_data = bazi_result.get('bazi', {})  # ✅ 正确提取
     ```

2. **潜在的错误场景**
   - 如果 `BaziService.calculate_bazi_full()` 调用失败，可能返回错误信息字符串
   - 如果某个地方缓存了错误的数据格式
   - 如果微服务间通信出现数据序列化问题

### 服务依赖关系

```
daily_fortune/monthly_fortune (API 服务)
    ↓ 依赖
BaziService (计算服务)
    ↓ 依赖
bazi_core_service (微服务, 端口 9001)
    ↓ 依赖
本地计算 (BaziCalculator)
```

**关键发现：** 当微服务未正确启动时，可能导致数据类型不一致的问题。

## ✅ 解决方案

### 1. 添加数据类型验证

在 `_generate_with_rules` 方法开头添加类型检查：

```python
@staticmethod
def _generate_with_rules(
    bazi_data: Dict[str, Any],
    liuri_info: Dict[str, Any],
    matched_rules: list,
    target_date: date
) -> Dict[str, Any]:
    """使用规则匹配生成运势分析（基于八字动态生成）"""
    # 添加数据类型验证
    if not isinstance(bazi_data, dict):
        raise TypeError(
            f"bazi_data 必须是字典类型，但实际是: {type(bazi_data).__name__}，"
            f"值: {str(bazi_data)[:100]}"
        )
    
    # ... 后续逻辑
```

**优点：**
- 提供更清晰的错误信息
- 帮助快速定位问题根源
- 避免错误传播到更深层次

### 2. 确保所有微服务正常启动

```bash
# 启动所有服务
./start_all_services.sh

# 检查所有服务是否正常运行
for port in 9001 9002 9003 9004 9005 9006 9007 8001; do
  echo "检查端口 $port:"
  lsof -i:$port || echo "  ⚠️ 服务未运行"
done

# 查看服务日志
tail -f logs/bazi_core_9001.log
tail -f logs/web_app_8001.log
```

### 3. 检查服务依赖链

如果某个服务调用失败，检查：

1. **网络连接**
   ```bash
   # 测试服务是否可访问
   curl http://127.0.0.1:9001/health || echo "服务不可达"
   ```

2. **服务响应格式**
   ```bash
   # 测试 API 返回格式
   curl -X POST http://127.0.0.1:8001/api/v1/bazi/calculate \
     -H "Content-Type: application/json" \
     -d '{"solar_date":"1987-01-07","solar_time":"09:55","gender":"male"}' \
     | jq .
   ```

3. **日志错误信息**
   ```bash
   # 查看最近的错误
   grep -i error logs/*.log
   ```

## 📚 预防措施

### 1. 开发规范更新

已更新 `docs/DEVELOPMENT_GUIDELINES.md`，添加：
- **微服务管理规范**章节
- 新增微服务的完整流程
- 微服务启动和停止的检查清单

### 2. 强制要求

**每次添加新微服务时，必须：**

✅ 在 `start_all_services.sh` 中添加启动命令  
✅ 在 `stop_all_services.sh` 中添加停止命令  
✅ 测试服务独立启动和停止  
✅ 测试服务集成启动和停止  
✅ 更新相关文档  

### 3. 代码审查要点

在 code review 时检查：

- [ ] 所有新服务是否添加到启动脚本？
- [ ] 所有新服务是否添加到停止脚本？
- [ ] 服务间调用是否有错误处理？
- [ ] 数据类型是否有验证？
- [ ] 是否有降级方案（如远程调用失败时使用本地计算）？

## 🔧 调试技巧

### 快速定位数据类型问题

1. **添加日志**
   ```python
   import logging
   logger = logging.getLogger(__name__)
   
   logger.debug(f"bazi_data 类型: {type(bazi_data)}")
   logger.debug(f"bazi_data 内容: {bazi_data}")
   ```

2. **使用 pdb 调试**
   ```python
   import pdb; pdb.set_trace()
   # 检查变量类型和值
   ```

3. **使用类型检查工具**
   ```bash
   # 使用 mypy 进行静态类型检查
   mypy server/services/daily_fortune_service.py
   ```

## 📖 相关文档

- [开发规范 - 微服务管理](./DEVELOPMENT_GUIDELINES.md#微服务管理规范)
- [服务启动指南](../启动服务指南.md)
- [微服务架构说明](../协议架构说明.md)

## ⏰ 问题记录

- **发生时间**: 2025-11-20
- **影响范围**: 今日运势、当月运势功能
- **严重程度**: 🔴 高（功能完全不可用）
- **解决时间**: 2025-11-20
- **根本原因**: 数据类型验证不足 + 微服务管理规范缺失

## 📝 经验教训

### 1. 永远不要相信外部数据的类型

即使函数签名声明了类型，也要在使用前验证：

```python
# ❌ 错误：直接使用
def process(data: Dict[str, Any]):
    name = data.get('name')  # 如果 data 不是 dict，立即报错
    
# ✅ 正确：先验证
def process(data: Dict[str, Any]):
    if not isinstance(data, dict):
        raise TypeError(f"Expected dict, got {type(data)}")
    name = data.get('name')
```

### 2. 微服务管理要系统化

- 新服务必须同步更新所有相关配置
- 建立服务启动/停止的检查清单
- 使用自动化测试验证服务依赖

### 3. 错误信息要清晰

```python
# ❌ 错误信息不明确
raise ValueError("数据错误")

# ✅ 错误信息清晰
raise TypeError(
    f"bazi_data 必须是字典类型，但实际是: {type(bazi_data).__name__}，"
    f"值的前100个字符: {str(bazi_data)[:100]}"
)
```

---

**记住：微服务架构中，任何新服务的添加都是系统性工程，必须更新所有相关的启动、停止、监控脚本！**

