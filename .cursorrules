# HiFate-bazi 八字系统 - AI 开发规范

## ⚠️ 核心原则（必须遵守）

### 🔴 0. 零停机原则 【设计前提】

> **所有设计必须保证服务不中断，这是一切设计的基础。**

| 场景 | 要求 | 实现方式 |
|------|------|----------|
| **热更新** | ✅ 零停机 | 代码修改自动重载，无需重启 |
| **版本发布** | ✅ 零停机 | 滚动更新，新旧容器平滑切换 |
| **功能增加** | ✅ 零停机 | 向后兼容，增量部署 |
| **数据库变更** | ✅ 零停机 | 只加字段不删字段，迁移脚本 |
| **配置更新** | ✅ 零停机 | 环境变量/Redis 热加载 |
| **规则更新** | ✅ 零停机 | 数据库+清缓存，无需重启 |

### 1. 最小影响原则 【最重要】
- **坚决不可改动与之无关的代码**
- 修改会引起其他功能变化时，**必须先咨询用户**
- 每次修改前明确影响范围（低/中/高）
- 高影响修改必须用户确认

### 2. gRPC 优先原则 【架构基础】
- **所有服务间交互必须使用 gRPC**
- **前端与后端交互通过 gRPC-Web 网关**
- REST API 仅作为兼容层，新功能必须同时注册 gRPC 端点

---

## 🔌 gRPC 交互规范 【重要】

### 架构概览
```
┌─────────────┐    gRPC-Web     ┌─────────────────┐     gRPC      ┌─────────────┐
│   前端      │ ───────────────→ │  Web 服务      │ ─────────────→ │  微服务     │
│  (Browser)  │                 │  (Port 8001)   │               │ (9001-9010) │
└─────────────┘                 └─────────────────┘               └─────────────┘
      │                                │                                │
      │                                ↓                                │
      │                         ┌─────────────┐                         │
      │                         │   MySQL     │←────────────────────────┘
      │                         │   Redis     │
      └─────────────────────────└─────────────┘
```

### 前端调用规范
```javascript
// ✅ 正确：使用 gRPC-Web 网关
const result = await api.post('/bazi/formula-analysis', {
    solar_date: '2025-01-15',
    solar_time: '12:00',
    gender: 'male'
});

// ❌ 错误：直接使用 REST API
const result = await fetch('/api/v1/bazi/formula-analysis', {...});
```

### 后端注册规范
```python
# 1. 在 server/api/v1/ 下创建 REST API
@router.post("/bazi/new-feature")
async def new_feature(request: NewFeatureRequest):
    ...

# 2. 在 server/api/grpc_gateway.py 注册 gRPC 端点（必须！）
@_register("/bazi/new-feature")
async def _handle_new_feature(payload: Dict[str, Any]):
    request_model = NewFeatureRequest(**payload)
    return await new_feature(request_model)
```

### 服务间调用规范
```python
# ✅ 正确：使用 gRPC 客户端
from src.clients.bazi_core_client_grpc import BaziCoreClientGrpc
result = BaziCoreClientGrpc.calculate_bazi(...)

# ❌ 错误：直接 HTTP 调用
import requests
result = requests.get('http://localhost:9001/api/...')
```

### gRPC 服务端口清单
| 服务 | 端口 | 用途 |
|------|------|------|
| Web 服务 | 8001 | HTTP + gRPC-Web 网关 |
| bazi-core | 9001 | 八字核心计算 |
| bazi-fortune | 9002 | 运势计算 |
| bazi-analyzer | 9003 | 八字分析 |
| bazi-rule | 9004 | 规则匹配 |
| fortune-analysis | 9005 | 运势分析 |
| payment | 9006 | 支付服务 |
| fortune-rule | 9007 | 运势规则 |
| intent | 9008 | 意图识别 |
| optimizer | 9009 | 提示优化 |
| desk-fengshui | 9010 | 风水分析 |

---

## 📜 规则开发规范 【核心】

### 🔴 规则存储规范 【必须遵守】

> **所有规则必须存储在数据库中，禁止从文件读取！**

| 存储方式 | 状态 | 说明 |
|---------|------|------|
| **MySQL 数据库** | ✅ **唯一来源** | 所有规则存储在 `bazi_rules` 表 |
| Excel 文件 (.xlsx) | ❌ **禁止** | 仅用于导入，导入后删除或归档 |
| Word 文件 (.docx) | ❌ **禁止** | 仅用于导入，导入后删除或归档 |
| JSON 文件 (.json) | ❌ **禁止** | 仅用于导入，导入后删除或归档 |
| 配置文件 | ❌ **禁止** | 不允许在代码中硬编码规则 |

**实现要求**：
```python
# ✅ 正确：从数据库加载规则
from server.services.rule_service import RuleService
rules = RuleService.match_rules(bazi_data, rule_types=['wealth'])

# ❌ 错误：从文件读取规则
import json
with open('rules.json') as f:
    rules = json.load(f)  # 禁止！

# ❌ 错误：从 Excel 读取规则
import pandas as pd
df = pd.read_excel('rules.xlsx')  # 禁止！
```

**代码检查清单**：
- [ ] 所有规则匹配使用 `RuleService`
- [ ] 没有 `load_from_file`、`read_excel`、`read_json` 等文件读取调用
- [ ] 没有硬编码的规则数据
- [ ] 规则导入脚本仅用于一次性导入，不用于运行时读取

**废弃代码标记**：
```python
# ⚠️ 已废弃：以下方法仅用于兼容，新代码禁止使用
# - RuleEngine.load_from_file()  # 已废弃
# - FormulaRuleService.load_rules()  # 已废弃，改用 RuleService
```

---

### 规则开发完整流程

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           规则开发标准流程                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  1. 准备阶段                                                                │
│     ├── 获取规则文档（Excel/JSON）                                           │
│     ├── 分析规则结构（类型、条件、结果）                                       │
│     └── 识别新条件类型（是否需要扩展规则引擎）                                  │
│                                                                             │
│  2. 条件类型检查                                                             │
│     ├── 检查 rule_condition.py 是否支持所需条件                               │
│     ├── 如不支持 → 先扩展规则引擎                                             │
│     └── 扩展后编写单元测试验证                                                │
│                                                                             │
│  3. 编写导入脚本                                                             │
│     ├── 位置：scripts/migration/import_xxx_rules.py                         │
│     ├── 解析规则文档                                                         │
│     ├── 转换为数据库格式                                                     │
│     ├── 标记歧义规则待确认                                                   │
│     └── 支持 --dry-run 预览                                                  │
│                                                                             │
│  4. 执行导入                                                                 │
│     ├── 先 --dry-run 确认无误                                                │
│     ├── 处理歧义规则（与用户确认）                                            │
│     ├── 正式导入数据库                                                       │
│     └── 验证规则数量和内容                                                   │
│                                                                             │
│  5. 前端适配                                                                 │
│     ├── 检查 typeLabels 是否包含新类型                                       │
│     ├── 检查 statistics 统计是否显示                                         │
│     └── 测试前端页面展示                                                     │
│                                                                             │
│  6. 后端适配                                                                 │
│     ├── 检查 formula_analysis.py 类型映射                                    │
│     ├── 检查 matched_rules 初始化                                            │
│     └── 检查 statistics 返回字段                                             │
│                                                                             │
│  7. 测试验证                                                                 │
│     ├── API 测试：curl 验证返回数据                                          │
│     ├── 前端测试：页面展示正常                                               │
│     └── 规则匹配：抽样验证规则匹配准确性                                      │
│                                                                             │
│  8. 提交代码                                                                 │
│     ├── 提交导入脚本                                                         │
│     ├── 提交规则引擎扩展（如有）                                             │
│     ├── 提交前后端适配代码                                                   │
│     └── 同步生产数据库                                                       │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 规则数据库结构

**表：`bazi_rules`**
```sql
CREATE TABLE bazi_rules (
    id INT AUTO_INCREMENT PRIMARY KEY,
    rule_code VARCHAR(100) NOT NULL UNIQUE,    -- 规则编码：FORMULA_类型_编号
    rule_name VARCHAR(200),                     -- 规则名称
    rule_type VARCHAR(50) NOT NULL,             -- 规则类型（英文）
    conditions JSON,                            -- 匹配条件（JSON格式）
    content JSON,                               -- 规则内容/结果
    description JSON,                           -- 原始描述信息
    priority INT DEFAULT 100,                   -- 优先级
    enabled TINYINT DEFAULT 1,                  -- 是否启用
    version INT DEFAULT 1,                      -- 版本号
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

### 规则编码规范

| 格式 | 示例 | 说明 |
|------|------|------|
| `FORMULA_类型_编号` | `FORMULA_事业_80001` | 新版格式（推荐） |
| `FORMULA_编号` | `FORMULA_10901` | 旧版格式（兼容） |

**类型映射（中英文）：**
| 中文 | 英文 | 说明 |
|------|------|------|
| 财富 | wealth | 财运相关 |
| 婚姻 | marriage | 婚配相关 |
| 事业 | career | 事业相关 |
| 子女 | children | 子女相关 |
| 性格 | character | 性格特征 |
| 总评 | summary | 综合评价 |
| 身体 | health | 健康相关 |
| 桃花 | peach_blossom | 桃花运 |
| 十神命格 | shishen | 十神分析 |

### 规则条件类型清单

#### 基础条件
| 条件类型 | 格式 | 说明 |
|---------|------|------|
| `gender` | `"male"` / `"female"` / `"*"` | 性别条件 |
| `wangshuai` | `["身旺"]` / `["身弱"]` | 旺衰条件 |

#### 四柱条件
| 条件类型 | 格式 | 说明 |
|---------|------|------|
| `pillar_in` | `{"pillar": "day", "part": "stem", "values": ["甲", "乙"]}` | 柱位匹配 |
| `pillar_equals` | `{"pillar": "day", "values": ["庚辰"]}` | 完整柱匹配 |
| `pillar_relation` | `{"pillar_a": "day", "pillar_b": "hour", "relation": "chong"}` | 柱间关系 |

#### 十神条件
| 条件类型 | 格式 | 说明 |
|---------|------|------|
| `ten_gods_main` | `{"names": ["正官", "七杀"], "min": 2}` | 主星数量 |
| `ten_gods_sub` | `{"names": ["食神"], "pillars": ["day"], "min": 1}` | 副星数量 |
| `ten_gods_total` | `{"names": ["比肩", "劫财"], "min": 3}` | 总十神数量 |
| `main_star_in_day` | `"七杀"` | 日柱主星 |
| `main_star_in_any_pillar` | `"食神"` | 任意柱主星 |
| `ten_gods_main_chong_count` | `{"min": 2}` | 主星被冲次数 |

#### 五行条件
| 条件类型 | 格式 | 说明 |
|---------|------|------|
| `element_total` | `{"element": "木", "min": 3}` | 五行数量 |
| `elements_count` | `{"木": {"min": 2}, "火": {"max": 1}}` | 多五行数量 |

#### 神煞条件
| 条件类型 | 格式 | 说明 |
|---------|------|------|
| `deities_in_any_pillar` | `"天乙贵人"` | 任意柱有神煞 |
| `deities_in_year` | `"华盖"` | 年柱有神煞 |
| `deities_in_month` | `"空亡"` | 月柱有神煞 |
| `deities_in_day` | `"桃花"` | 日柱有神煞 |
| `deities_in_hour` | `"驿马"` | 时柱有神煞 |
| `deities_same_pillar` | `["华盖", "空亡"]` | 同柱多神煞 |

#### 十二长生条件
| 条件类型 | 格式 | 说明 |
|---------|------|------|
| `star_fortune_in_day` | `"帝旺"` / `["死", "绝"]` | 日支十二长生 |
| `star_fortune_in_hour` | `"墓"` | 时支十二长生 |
| `liunian_star_fortune` | `"绝"` | 流年十二长生 |

#### 关系条件
| 条件类型 | 格式 | 说明 |
|---------|------|------|
| `branch_sanxing` | `true` | 地支三刑 |
| `stem_wuhe_pairs` | `{"min": 1}` | 天干五合对数 |
| `pillar_branch_xing_chong` | `true` | 柱地支被刑冲 |
| `multi_chong` | `{"min": 2}` | 多重冲 |

#### 特殊条件
| 条件类型 | 格式 | 说明 |
|---------|------|------|
| `xishen` | `"比肩"` | 喜用神匹配 |
| `xishen_in` | `["食神", "伤官"]` | 喜用神在列表中 |
| `taiyuan_shengong_minggong` | `{"taiyuan": "癸丑"}` | 胎元身宫命宫 |
| `stems_branches_count` | `{"names": ["壬", "癸", "子"], "min": 3}` | 天干地支混合计数 |
| `not` | `{...条件...}` | 否定条件 |

#### 组合条件
| 条件类型 | 格式 | 说明 |
|---------|------|------|
| `all` | `[条件1, 条件2, ...]` | 所有条件都满足（AND） |
| `any` | `[条件1, 条件2, ...]` | 任一条件满足（OR） |

### 规则导入脚本模板

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
规则导入脚本：import_xxx_rules.py

使用方法：
  python scripts/migration/import_xxx_rules.py --dry-run  # 预览
  python scripts/migration/import_xxx_rules.py            # 正式导入
"""

import sys
import os
import json
import argparse
from typing import Dict, Any, Tuple, Optional, List

# 添加项目根目录到路径
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from server.config.mysql_config import get_mysql_connection, return_mysql_connection


class RuleConverter:
    """规则转换器"""
    
    # 类型映射
    TYPE_MAPPING = {
        '财富': 'wealth',
        '婚姻': 'marriage',
        '事业': 'career',
        '子女': 'children',
        '性格': 'character',
        '总评': 'summary',
        '身体': 'health',
        '桃花': 'peach_blossom',
    }
    
    def convert(self, raw_rule: Dict) -> Tuple[Optional[Dict], Optional[str]]:
        """
        转换原始规则为数据库格式
        
        Returns:
            (rule_dict, ambiguity_reason) - 如果有歧义返回原因
        """
        # 1. 提取字段
        rule_id = raw_rule.get('ID')
        rule_type_cn = raw_rule.get('类型', '')
        condition1 = raw_rule.get('筛选条件1', '')
        condition2 = raw_rule.get('筛选条件2', '')
        result = raw_rule.get('结果', '')
        gender = raw_rule.get('性别', '')
        
        # 2. 转换类型
        rule_type = self.TYPE_MAPPING.get(rule_type_cn, rule_type_cn.lower())
        
        # 3. 解析条件
        conditions, ambiguity = self._parse_conditions(condition1, condition2, gender)
        if ambiguity:
            return None, f"ID {rule_id}: {ambiguity}"
        
        # 4. 构建规则
        rule = {
            'rule_code': f'FORMULA_{rule_type_cn}_{rule_id}',
            'rule_name': f'{rule_type_cn}规则-{rule_id}',
            'rule_type': rule_type,
            'conditions': conditions,
            'content': {'text': result},
            'description': {
                '筛选条件1': condition1,
                '筛选条件2': condition2,
                '性别': gender
            }
        }
        
        return rule, None
    
    def _parse_conditions(self, cond1: str, cond2: str, gender: str) -> Tuple[Dict, Optional[str]]:
        """解析条件文本为JSON格式"""
        conditions = {}
        
        # 解析性别
        if gender == '男':
            conditions['gender'] = 'male'
        elif gender == '女':
            conditions['gender'] = 'female'
        
        # 解析具体条件（根据实际规则格式实现）
        # ...
        
        return conditions, None


def import_rules(rules: List[Dict], dry_run: bool = False) -> Tuple[int, int, List[str]]:
    """
    导入规则到数据库
    
    Returns:
        (inserted, updated, ambiguous_rules)
    """
    inserted = 0
    updated = 0
    ambiguous = []
    
    if dry_run:
        print("=== DRY RUN 模式，不会修改数据库 ===\n")
    
    conn = get_mysql_connection()
    try:
        with conn.cursor() as cursor:
            for rule in rules:
                if dry_run:
                    print(f"将导入: {rule['rule_code']}")
                    continue
                
                # 检查是否存在
                cursor.execute(
                    "SELECT id FROM bazi_rules WHERE rule_code = %s",
                    (rule['rule_code'],)
                )
                existing = cursor.fetchone()
                
                if existing:
                    # 更新
                    cursor.execute("""
                        UPDATE bazi_rules SET
                            rule_name = %s,
                            rule_type = %s,
                            conditions = %s,
                            content = %s,
                            description = %s,
                            version = version + 1
                        WHERE rule_code = %s
                    """, (
                        rule['rule_name'],
                        rule['rule_type'],
                        json.dumps(rule['conditions'], ensure_ascii=False),
                        json.dumps(rule['content'], ensure_ascii=False),
                        json.dumps(rule['description'], ensure_ascii=False),
                        rule['rule_code']
                    ))
                    updated += 1
                else:
                    # 插入
                    cursor.execute("""
                        INSERT INTO bazi_rules 
                        (rule_code, rule_name, rule_type, conditions, content, description)
                        VALUES (%s, %s, %s, %s, %s, %s)
                    """, (
                        rule['rule_code'],
                        rule['rule_name'],
                        rule['rule_type'],
                        json.dumps(rule['conditions'], ensure_ascii=False),
                        json.dumps(rule['content'], ensure_ascii=False),
                        json.dumps(rule['description'], ensure_ascii=False)
                    ))
                    inserted += 1
            
            if not dry_run:
                conn.commit()
    finally:
        return_mysql_connection(conn)
    
    return inserted, updated, ambiguous


def main():
    parser = argparse.ArgumentParser(description='规则导入脚本')
    parser.add_argument('--dry-run', action='store_true', help='预览模式，不修改数据库')
    args = parser.parse_args()
    
    # 加载规则数据
    # ...
    
    # 导入规则
    inserted, updated, ambiguous = import_rules(rules, args.dry_run)
    
    print(f"\n=== 导入结果 ===")
    print(f"新增: {inserted} 条")
    print(f"更新: {updated} 条")
    print(f"歧义: {len(ambiguous)} 条")


if __name__ == '__main__':
    main()
```

---

## 🔄 问题复盘机制 【重要】

### 复盘流程

每次遇到问题后，必须完成以下步骤：

1. **问题记录**
   - 记录问题现象、错误信息、复现步骤
   - 记录问题发生时间、影响范围

2. **根因分析**
   - 分析问题根本原因（不是表面现象）
   - 检查是否违反开发规范
   - 检查是否有类似问题历史

3. **解决方案**
   - 实施修复方案
   - 验证修复效果
   - 确保不会再次出现

4. **规范更新**
   - 将问题复盘记录到开发规范
   - 更新相关检查清单
   - 添加预防措施

5. **代码审查**
   - 检查是否有类似代码需要修复
   - 确保所有相关代码都符合规范

### 复盘记录格式

```markdown
## 问题复盘：[问题标题] - YYYY-MM-DD

### 问题描述
- **现象**：具体问题表现
- **影响**：影响范围和严重程度
- **复现**：复现步骤

### 根因分析
- **直接原因**：表面原因
- **根本原因**：深层原因
- **规范违反**：违反了哪些开发规范

### 解决方案
- **修复内容**：具体修改
- **验证结果**：测试验证情况

### 预防措施
- **规范更新**：更新的规范内容
- **检查清单**：新增的检查项
- **代码审查**：需要检查的代码范围
```

---

## 🚨 常见问题与解决方案

### 问题复盘：十神命格规则匹配失败 - 2025-11-28

#### 问题描述
- **现象**：生日 1987-01-07 09:00 无法匹配十神命格规则
- **影响**：所有十神命格规则都无法匹配，影响规则分析功能
- **复现**：调用 `/bazi/formula-analysis` API，`shishen_count` 始终为 0

#### 根因分析
1. **直接原因**：
   - `formula_analysis.py` 中十神命格使用 `FormulaRuleService` 匹配
   - `FormulaRuleService` 期望旧格式（文本条件），但数据库规则已迁移为 JSON 格式
   - 规则条件格式问题：`hidden_stars_in_year` 包含文本描述（如"日柱副星有正财"）

2. **根本原因**：
   - 规则迁移后未统一匹配服务
   - 规则引擎未支持混合条件格式（文本描述+十神名称）
   - 缺少规则匹配的统一测试

3. **规范违反**：
   - ❌ 未使用统一的 `RuleService` 匹配规则
   - ❌ 规则条件格式不统一
   - ❌ 缺少规则匹配的验证测试

#### 解决方案
1. **修改 `formula_analysis.py`**：
   - 移除 `FormulaRuleService` 特殊处理
   - 统一使用 `RuleService` 匹配所有规则（包括十神命格）

2. **增强 `rule_condition.py`**：
   - 增强 `hidden_stars_in_*` 条件处理
   - 支持解析文本描述（如"日柱副星有正财"）并检查对应柱

#### 预防措施
1. **规范更新**：
   - ✅ 所有规则必须使用 `RuleService` 匹配
   - ✅ 规则条件格式必须统一为 JSON
   - ✅ 新增规则类型必须同步更新前后端

2. **检查清单**：
   - [ ] 新规则类型是否使用 `RuleService` 匹配
   - [ ] 规则条件格式是否符合 JSON 规范
   - [ ] 前后端是否同步支持新规则类型
   - [ ] 是否编写了规则匹配测试

3. **代码审查**：
   - 检查所有使用 `FormulaRuleService` 的代码
   - 检查规则条件格式是否统一
   - 检查规则匹配逻辑是否完整

---

### 问题1：数据库名配置错误

**症状**：
```
Unknown database 'bazi_system'
```

**原因**：`server/config/mysql_config.py` 中默认数据库名不正确

**解决**：
```python
# 修改 mysql_config.py
'database': os.getenv('MYSQL_DATABASE', 'hifate_bazi'),  # 不是 bazi_system
```

**预防**：
- 检查 `env.template` 中的 `MYSQL_DATABASE` 值
- 确保默认值与实际数据库一致

---

### 问题2：规则ID包含中文导致解析失败

**症状**：
```
invalid literal for int() with base 10: '财富_20106'
```

**原因**：规则ID格式不统一（`FORMULA_80001` vs `FORMULA_财富_20106`）

**解决**：
```python
# 兼容两种格式
try:
    numeric_id = int(original_id)
except ValueError:
    parts = original_id.rsplit('_', 1)
    if len(parts) == 2 and parts[1].isdigit():
        numeric_id = int(parts[1])
    else:
        numeric_id = hash(original_id) % 1000000
```

**预防**：
- 导入时统一使用 `FORMULA_类型_编号` 格式
- 在数据库中保持 `rule_type` 字段为英文

---

### 问题3：规则类型不一致

**症状**：前端显示不出新增的规则类型（如事业、子女）

**原因**：数据库 `rule_type` 字段值不统一（`formula_career` vs `career`）

**解决**：
```sql
-- 统一规则类型名称
UPDATE bazi_rules SET rule_type = 'career' WHERE rule_type = 'formula_career';
UPDATE bazi_rules SET rule_type = 'children' WHERE rule_type = 'formula_children';
```

**预防**：
- 导入脚本中使用统一的英文类型名
- 不要使用 `formula_` 前缀

---

### 问题4：前端类型标签缺失

**症状**：前端页面没有显示新类型的标签页

**原因**：`frontend/formula-analysis.html` 中 `typeLabels` 未定义新类型

**解决**：
```javascript
const typeLabels = {
    'wealth': { name: '💰 财富', color: '#f39c12' },
    'marriage': { name: '💑 婚配', color: '#e74c3c' },
    'career': { name: '💼 事业', color: '#1abc9c' },      // 新增
    'children': { name: '👶 子女', color: '#e67e22' },    // 新增
    // ...
};
```

**预防**：
- 新增规则类型时同步更新前端 `typeLabels`
- 同步更新 `displayStatistics` 函数

---

### 问题5：新条件类型不支持

**症状**：规则无法匹配，日志显示条件未处理

**原因**：`rule_condition.py` 中未实现对应条件类型

**解决**：在 `EnhancedRuleCondition.match` 中添加条件处理逻辑

**预防**：
- 导入前检查所有条件类型是否已支持
- 不支持的条件先扩展规则引擎再导入

---

### 问题6：gRPC 端点未注册

**症状**：前端调用 API 返回错误或无响应

**原因**：`grpc_gateway.py` 中未注册对应端点

**解决**：
```python
# 在 grpc_gateway.py 中注册
@_register("/bazi/new-feature")
async def _handle_new_feature(payload: Dict[str, Any]):
    request_model = NewFeatureRequest(**payload)
    return await new_feature(request_model)
```

**预防**：
- 新增 API 时必须同时注册 gRPC 端点
- 测试时验证 gRPC-Web 调用是否正常

---

## 📁 项目架构

### 前端架构 `frontend/`
```
frontend/
├── js/
│   ├── api.js                  # gRPC-Web 客户端（核心）
│   ├── config.js               # API 配置
│   ├── fortune.js              # 运势数据逻辑
│   ├── fortune-timeline.js     # 运势 UI 渲染
│   └── ...
├── css/                        # 样式文件
└── *.html                      # 页面文件
```

### 后端架构 `server/`
```
server/
├── api/
│   ├── grpc_gateway.py         # gRPC-Web 网关（核心）
│   └── v1/                     # REST API
│       ├── formula_analysis.py # 算法公式分析
│       └── ...
├── services/                   # 业务逻辑
│   ├── rule_service.py         # 规则匹配服务
│   └── ...
├── engines/                    # 规则引擎
│   ├── rule_engine.py          # 核心引擎
│   └── rule_condition.py       # 条件匹配（扩展点）
├── config/
│   └── mysql_config.py         # MySQL 配置（注意默认值）
└── db/                         # 数据库连接
```

### 微服务架构 `services/`
```
services/
├── bazi_core/                  # 八字核心服务 (9001)
├── bazi_fortune/               # 运势服务 (9002)
├── bazi_analyzer/              # 分析服务 (9003)
├── bazi_rule/                  # 规则服务 (9004)
├── fortune_analysis/           # 运势分析 (9005)
├── payment_service/            # 支付服务 (9006)
├── fortune_rule/               # 运势规则 (9007)
├── intent_service/             # 意图识别 (9008)
├── prompt_optimizer/           # 提示优化 (9009)
└── desk_fengshui/              # 风水分析 (9010)
```

### 脚本目录 `scripts/`
```
scripts/
├── migration/                  # 数据迁移脚本
│   ├── import_2025_1128_rules.py   # 规则导入示例
│   └── import_confirmed_rules.py   # 确认规则导入
├── db/                         # 数据库脚本
│   └── sync_db.sh              # 数据库同步
└── ...
```

---

## 🔒 核心文件（修改前必须咨询）

| 文件 | 作用 | 风险 |
|------|------|------|
| `server/api/grpc_gateway.py` | gRPC-Web 网关 | 极高 |
| `server/engines/rule_condition.py` | 规则条件匹配 | 高 |
| `server/config/mysql_config.py` | MySQL 配置 | 高 |
| `src/bazi_calculator.py` | 核心八字计算 | 极高 |
| `frontend/js/api.js` | 前端 gRPC 客户端 | 高 |
| `proto/*.proto` | gRPC 协议定义 | 高 |

---

## 📝 代码规范

### 数据库配置默认值
```python
# ✅ 正确：使用实际的数据库名
'database': os.getenv('MYSQL_DATABASE', 'hifate_bazi'),

# ❌ 错误：使用过时的数据库名
'database': os.getenv('MYSQL_DATABASE', 'bazi_system'),
```

### JSON 序列化
```python
# ✅ 正确：支持中文
json.dumps(data, ensure_ascii=False)

# ❌ 错误：中文被转义
json.dumps(data)  # 输出 \u4e2d\u6587
```

### 规则类型命名
```python
# ✅ 正确：使用英文小写
rule_type = 'career'
rule_type = 'children'

# ❌ 错误：使用中文或带前缀
rule_type = '事业'
rule_type = 'formula_career'
```

---

## 🚀 服务管理

### 启动服务
```bash
# 启动主服务
python3 server/start.py

# 或使用脚本
./start.sh
```

### 测试 API
```bash
# 测试 gRPC-Web 网关
curl -s -X POST 'http://127.0.0.1:8001/api/v1/bazi/formula-analysis' \
  -H 'Content-Type: application/json' \
  -d '{"solar_date": "1990-01-15", "solar_time": "12:00", "gender": "male"}'
```

### 查看日志
```bash
tail -f logs/server_8001.log
```

---

## 📦 Git 提交规范

### Commit Message 格式
```
[类型] 简短描述

- 修改文件：列出文件
- 功能说明：详细说明
- 测试情况：测试结果
```

### 类型标签
- `[新增]` - 新功能/新规则
- `[修复]` - Bug修复
- `[优化]` - 性能优化
- `[重构]` - 代码重构
- `[规则]` - 规则相关变更
- `[配置]` - 配置修改

---

## 📖 Gitee 仓库

| 项目 | 值 |
|------|-----|
| **仓库地址** | https://gitee.com/zhoudengtang/hifate-prod.git |
| **本地 remote** | gitee |
| **默认分支** | master |

### 提交流程
```bash
git add .
git commit -m "[类型] 描述"
git push gitee master
```

### 部署到生产
```bash
./deploy.sh  # 选择 1) 完整部署
```

**📖 详细部署文档**：`docs/Docker生产部署完整指南.md`

---

## 🐳 Docker 基础镜像优化

### 📋 原理

使用预构建的基础镜像（包含所有 Python 依赖），大幅加速部署：

```
传统方式：每次部署都安装依赖（5-10分钟）
优化方式：基础镜像已含依赖，只需复制代码（10-20秒）
```

### 🚀 使用流程

**1. 首次构建基础镜像**（仅需一次，约 5-10 分钟）

```bash
./scripts/docker/build_base.sh
```

**2. 检查基础镜像状态**

```bash
./scripts/docker/check_base.sh
```

**3. 正常部署**（快速，10-20秒）

```bash
docker compose up -d --build web
```

### ⚠️ 何时需要重建基础镜像

| 场景 | 是否需要重建 | 说明 |
|------|------------|------|
| 修改代码 | ❌ 不需要 | 直接部署即可 |
| 修改 requirements.txt | ✅ **必须重建** | 依赖变更 |
| 修改 Dockerfile.base | ✅ 需要重建 | 基础镜像配置变更 |

### 🔒 安全机制

1. **跨平台兼容**：使用 `--platform linux/amd64` 确保 Mac M1/Intel 都能构建
2. **保险层**：应用 Dockerfile 会再次执行 `pip install`，确保依赖完整
3. **自动检查**：`check_base.sh` 会检测 requirements.txt 是否变更

### 📊 性能对比

| 场景 | 传统方式 | 基础镜像 | 提升 |
|------|---------|---------|------|
| 首次部署 | 10-15分钟 | 5-10分钟（构建基础镜像） | 1次性 |
| 代码更新 | 1-2分钟 | **10-20秒** | **6-12倍** |
| 依赖更新 | 10-15分钟 | 5-10分钟（重建基础镜像） | 1次性 |

### 🛠️ 维护命令

```bash
# 构建基础镜像
./scripts/docker/build_base.sh

# 检查是否需要更新
./scripts/docker/check_base.sh

# 查看基础镜像信息
docker images hifate-base

# 删除旧版本（可选）
docker rmi hifate-base:20241128
```

---

## 💡 开发原则

1. **🔴 零停机优先**：所有设计必须支持不停机更新
2. **🔌 gRPC 优先**：服务间交互必须使用 gRPC
3. **📜 规则数据库化**：规则存数据库，支持热更新，**禁止从文件读取**
4. **🔄 向后兼容**：只加不删，保持兼容
5. **✅ 先测试后提交**：修改后立即测试
6. **📝 规范命名**：类型用英文，ID 统一格式
7. **🔄 问题复盘**：每次问题必须复盘并更新规范

---

## 📚 文档维护规范

### 🔄 文档同步原则

**核心原则**：操作更新时，文档必须同步更新

### 📝 需要同步更新的场景

| 场景 | 需要更新的文档 | 更新内容 |
|------|--------------|---------|
| 新增部署步骤 | `docs/Docker生产部署完整指南.md` | 添加新步骤 |
| 修改部署命令 | `docs/Docker生产部署完整指南.md` | 更新命令 |
| 新增故障排查 | `docs/Docker生产部署完整指南.md` | 添加问题解决方案 |
| 修改配置项 | `docs/Docker生产部署完整指南.md` | 更新配置说明 |
| 新增脚本 | `docs/Docker生产部署完整指南.md` | 添加脚本使用说明 |
| 修改开发流程 | `.cursorrules` | 更新相关章节 |

### ✅ 文档更新检查清单

每次修改部署相关操作时，必须检查：

- [ ] 是否更新了 `docs/Docker生产部署完整指南.md`
- [ ] 是否更新了 `.cursorrules` 中的相关章节
- [ ] 是否更新了脚本中的注释
- [ ] 是否更新了 README（如有）

### 📋 文档维护流程

1. **修改操作** → 立即更新文档
2. **提交代码** → 同时提交文档更新
3. **验证部署** → 验证文档准确性
4. **标记更新日期** → 在文档顶部更新日期

### 🎯 主要部署文档

| 文档 | 用途 | 维护频率 |
|------|------|---------|
| `docs/Docker生产部署完整指南.md` | **主要部署文档** | 每次操作变更 |
| `docs/Docker基础镜像优化.md` | 基础镜像详细说明 | 基础镜像变更时 |
| `.cursorrules` | 开发规范 | 规范变更时 |

---

**记住**：
- 新增 API 必须同时注册 gRPC 端点
- 新增规则类型必须同步更新前后端
- 数据库配置使用 `hifate_bazi` 而非 `bazi_system`
- 规则 `rule_type` 使用英文小写
- **所有规则必须从数据库读取，禁止从文件读取**
- **所有规则匹配必须使用 `RuleService`，禁止使用 `FormulaRuleService`**
- **每次问题必须复盘并更新开发规范**
- **操作更新时，文档必须同步更新**
