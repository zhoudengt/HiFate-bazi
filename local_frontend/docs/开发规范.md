# 前端开发规范

> **本文档定义了HiFate-bazi项目的前端开发规范，所有前端代码必须遵循本规范。**

## 一、代码规范

### 1.1 命名规范

- **文件名**：kebab-case（如：`smart-fortune.js`, `error-handler.js`）
- **类名**：PascalCase（如：`ErrorHandler`, `DomUtils`）
- **函数/变量**：camelCase（如：`showError`, `errorMessage`）
- **常量**：UPPER_SNAKE_CASE（如：`API_BASE_URL`, `TOKEN_KEY`）
- **私有方法/属性**：下划线前缀（如：`_findErrorContainer`, `_privateMethod`）

### 1.2 文件组织规范

```
local_frontend/
├── js/
│   ├── core/              # 核心工具类（统一使用）
│   │   ├── error-handler.js
│   │   ├── dom-utils.js
│   │   └── validator.js
│   ├── services/          # 业务服务（可选，未来模块化）
│   └── [页面名].js        # 页面级脚本
├── css/
│   ├── common.css         # 公共样式（必须引入）
│   └── [页面名].css       # 页面样式
└── docs/
    └── 开发规范.md        # 本文档
```

### 1.3 代码风格规范

- 使用 **ES6+** 语法
- 使用 **async/await** 而非 Promise.then
- 使用 **const/let**，避免 var
- 函数不超过 **50行**
- 文件不超过 **300行**
- 每行不超过 **100字符**

### 1.4 注释规范

- 所有工具类和公共方法必须有 JSDoc 注释
- 复杂逻辑必须有注释说明
- TODO 和 FIXME 必须标注负责人和日期

```javascript
/**
 * 显示错误信息
 * @param {string} message - 错误消息
 * @param {Object} options - 配置选项
 * @returns {HTMLElement|null} 错误容器元素
 */
static showError(message, options = {}) {
    // 实现...
}
```

## 二、错误处理规范

### 2.1 统一使用 ErrorHandler

**禁止**：
```javascript
// ❌ 错误：直接使用 alert
alert('错误信息');

// ❌ 错误：直接操作 DOM
document.getElementById('error').innerHTML = '错误';

// ❌ 错误：直接 innerHTML
errorDiv.innerHTML = '<div class="error">错误</div>';
```

**正确**：
```javascript
// ✅ 正确：使用统一错误处理工具
ErrorHandler.showError('错误信息', {
    containerId: 'errorMessage',
    sectionId: 'resultSection',  // 如果需要显示相关区域
    scrollTo: true
});
```

### 2.2 错误处理检查清单

所有API调用和DOM操作必须：
- [ ] 使用 try-catch 捕获错误
- [ ] 使用 `ErrorHandler.showError()` 显示错误
- [ ] 错误显示前确保UI区域可见（使用 `sectionId` 参数）
- [ ] 关键阶段提前显示UI区域（使用 `ErrorHandler.showSection()`）
- [ ] 错误信息用户友好（不暴露技术细节）
- [ ] 控制台记录详细错误（便于调试）

### 2.3 API错误处理

```javascript
try {
    const result = await api.post('/bazi/calculate', data);
    if (!result.success) {
        ErrorHandler.handleApiError(result.error, {
            containerId: 'errorMessage',
            sectionId: 'resultSection'
        });
        return;
    }
    // 处理成功结果...
} catch (error) {
    ErrorHandler.handleApiError(error, {
        containerId: 'errorMessage',
        sectionId: 'resultSection'
    });
}
```

## 三、DOM操作规范

### 3.1 统一使用 DomUtils

**禁止**：
```javascript
// ❌ 错误：直接操作 DOM
document.getElementById('result').innerHTML = content;
document.getElementById('result').style.display = 'block';
```

**正确**：
```javascript
// ✅ 正确：使用统一 DOM 工具
DomUtils.setText('result', content);
DomUtils.show('result');
```

### 3.2 DOM操作检查清单

所有DOM操作必须：
- [ ] 使用 `DomUtils` 工具类
- [ ] 操作前检查元素存在（DomUtils会自动检查）
- [ ] 同时更新内容和显示状态
- [ ] 避免直接 `innerHTML`（优先使用 `textContent`）
- [ ] 事件监听器及时清理（防止内存泄漏）

### 3.3 常用DOM操作

```javascript
// 设置文本
DomUtils.setText('elementId', '文本内容');

// 显示/隐藏
DomUtils.show('elementId');
DomUtils.hide('elementId');

// 设置表单值
DomUtils.setFormValue('inputId', 'value');

// 获取表单值
const value = DomUtils.getFormValue('inputId');

// 绑定事件
const unbind = DomUtils.on('buttonId', 'click', handler);
// 解绑：unbind();
```

## 四、数据验证规范

### 4.1 统一使用 Validator

**禁止**：
```javascript
// ❌ 错误：不验证或简单验证
if (!solar_date) {
    alert('请输入日期');
}
```

**正确**：
```javascript
// ✅ 正确：使用统一验证工具
try {
    Validator.required(solar_date, '出生日期');
    Validator.date(solar_date, '出生日期');
    Validator.required(solar_time, '出生时间');
    Validator.time(solar_time, '出生时间');
    Validator.gender(gender, '性别');
} catch (error) {
    ErrorHandler.showError(error.message);
    return;
}
```

### 4.2 八字输入验证

```javascript
// 使用专门的八字验证方法
try {
    Validator.baziInput({
        solar_date: '1990-01-15',
        solar_time: '12:00',
        gender: 'male'
    });
} catch (error) {
    ErrorHandler.showError(error.message);
    return;
}
```

## 五、API调用规范

### 5.1 统一使用 api 对象

**禁止**：
```javascript
// ❌ 错误：直接使用 fetch
fetch('/api/v1/bazi/calculate', {...});
```

**正确**：
```javascript
// ✅ 正确：使用统一的 api 对象
const result = await api.post('/bazi/calculate', {
    solar_date: '1990-01-15',
    solar_time: '12:00',
    gender: 'male'
});
```

### 5.2 API调用流程

```
发起API调用
    ↓
参数验证（使用 Validator）
    ↓
显示加载状态（统一 loading 组件）
    ↓
调用API（使用 api.post/request）
    ↓
处理响应（统一响应格式）
    ↓
更新UI（使用 DomUtils）
    ↓
错误处理（统一 ErrorHandler）
```

### 5.3 API调用检查清单

- [ ] 使用统一 `api` 对象
- [ ] 调用前验证参数（使用 `Validator`）
- [ ] 显示加载状态
- [ ] 使用 try-catch 处理错误
- [ ] 使用 `ErrorHandler.handleApiError()` 处理API错误
- [ ] 响应数据验证
- [ ] 更新UI前检查元素存在

## 六、页面结构规范

### 6.1 HTML结构

每个页面应包含：
- 错误消息容器：`<div id="errorMessage" class="error-message"></div>`
- 加载状态容器（可选）：`<div id="loading" class="loading"></div>`
- 结果容器（可选）：`<div id="result"></div>`

### 6.2 脚本引入顺序

```html
<!-- 1. 配置 -->
<script src="config.js"></script>

<!-- 2. 核心工具类 -->
<script src="js/core/error-handler.js"></script>
<script src="js/core/dom-utils.js"></script>
<script src="js/core/validator.js"></script>

<!-- 3. API客户端 -->
<script src="js/api.js"></script>

<!-- 4. 业务逻辑（如需要） -->
<script src="js/auth.js"></script>

<!-- 5. 页面脚本 -->
<script>
    // 页面特定逻辑
</script>
```

### 6.3 样式引入

```html
<!-- 公共样式（必须） -->
<link rel="stylesheet" href="css/common.css">

<!-- 页面样式（可选） -->
<link rel="stylesheet" href="css/[页面名].css">
```

## 七、开发检查清单

### 7.1 开发前检查

- [ ] 阅读相关开发规范
- [ ] 理解功能需求
- [ ] 设计代码结构
- [ ] 准备测试用例

### 7.2 开发中检查

- [ ] 使用统一工具类（ErrorHandler、DomUtils、Validator）
- [ ] 遵循代码规范
- [ ] 编写错误处理
- [ ] 代码注释完整

### 7.3 开发后检查

- [ ] 手动功能验证
- [ ] 错误场景测试
- [ ] 跨浏览器测试（Chrome、Firefox、Safari）
- [ ] 响应式布局检查

### 7.4 提交前检查

- [ ] 无 console.log（生产代码）
- [ ] 无调试代码
- [ ] 无 TODO/FIXME（或已标注）
- [ ] 代码已格式化
- [ ] 注释完整

## 八、常见问题

### 8.1 错误处理问题

**问题**：错误信息不显示

**原因**：UI区域初始为 `display:none`，错误处理时未显示

**解决**：使用 `ErrorHandler.showError()` 的 `sectionId` 参数

```javascript
ErrorHandler.showError('错误信息', {
    sectionId: 'resultSection'  // 自动显示相关区域
});
```

### 8.2 DOM操作问题

**问题**：`Cannot read property 'innerHTML' of null`

**原因**：元素不存在时直接操作

**解决**：使用 `DomUtils`，会自动检查元素存在

```javascript
// DomUtils 会自动检查，元素不存在时静默失败
DomUtils.setText('elementId', 'content');
```

### 8.3 数据验证问题

**问题**：无效数据导致API错误

**原因**：未进行数据验证

**解决**：使用 `Validator` 在调用API前验证

```javascript
try {
    Validator.baziInput(data);
} catch (error) {
    ErrorHandler.showError(error.message);
    return;
}
```

## 九、最佳实践

1. **防御性编程**：所有外部依赖都有降级方案
2. **错误优先**：先处理错误情况，再处理成功情况
3. **用户体验**：错误信息友好，加载状态明确
4. **可维护性**：代码清晰，注释完整，易于理解
5. **可测试性**：函数职责单一，便于单元测试

## 十、更新记录

- 2025-01-XX: 创建规范文档，建立统一工具类
- ...

---

**违反规范的代码将被要求重构，不得合并到主分支。**

