# HiFate-bazi 测试环境自动部署
# 触发条件：推送到 master 分支（测试环境：123.57.216.15）
# 功能：从阿里云容器镜像服务 (ACR) 拉取镜像并部署到测试服务器
# 
# 标准流程：
#   1. build-and-push.yml 构建镜像并推送到 ACR
#   2. 本 workflow 从 ACR 拉取镜像
#   3. 部署到测试服务器（零停机滚动更新）

name: 🧪 Deploy to Test Environment

on:
  push:
    branches: [ master ]
  workflow_dispatch:

jobs:
  # 构建并推送镜像（依赖 build-and-push.yml 的逻辑）
  build:
    name: 构建 Docker 镜像
    runs-on: ubuntu-latest
    permissions:
      contents: read
    outputs:
      image_tag: ${{ steps.set_output.outputs.image_tag }}
      acr_configured: ${{ steps.check_acr.outputs.acr_configured }}
    
    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4
      
      - name: 🔧 Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          platforms: linux/amd64
      
      - name: 🔍 Check ACR configuration
        id: check_acr
        run: |
          if [ -n "${{ secrets.ACR_REGISTRY }}" ] && [ -n "${{ secrets.ACR_NAMESPACE }}" ] && \
             [ -n "${{ secrets.ACR_USERNAME }}" ] && [ -n "${{ secrets.ACR_PASSWORD }}" ]; then
            echo "acr_configured=true" >> $GITHUB_OUTPUT
            echo "✅ ACR secrets 已配置"
            echo "ACR_REGISTRY=${{ secrets.ACR_REGISTRY }}" >> $GITHUB_OUTPUT
            echo "ACR_NAMESPACE=${{ secrets.ACR_NAMESPACE }}" >> $GITHUB_OUTPUT
          else
            echo "acr_configured=false" >> $GITHUB_OUTPUT
            echo "❌ ACR secrets 未配置，无法构建和推送镜像"
            echo "需要的 secrets: ACR_REGISTRY, ACR_NAMESPACE, ACR_USERNAME, ACR_PASSWORD"
            exit 1
          fi
      
      - name: 🔐 Login to ACR
        if: steps.check_acr.outputs.acr_configured == 'true'
        uses: docker/login-action@v3
        with:
          registry: ${{ secrets.ACR_REGISTRY }}
          username: ${{ secrets.ACR_USERNAME }}
          password: ${{ secrets.ACR_PASSWORD }}
      
      - name: 📋 Extract metadata
        id: meta
        if: steps.check_acr.outputs.acr_configured == 'true'
        uses: docker/metadata-action@v5
        with:
          images: ${{ secrets.ACR_REGISTRY }}/${{ secrets.ACR_NAMESPACE }}/hifate-bazi
          tags: |
            type=ref,event=branch
            type=sha,prefix=
            type=raw,value=latest
      
      - name: 🐳 Build and push Docker image
        if: steps.check_acr.outputs.acr_configured == 'true'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64
          provenance: false  # ⚠️ ACR 必需！不支持 provenance
          sbom: false  # ⚠️ ACR 必需！不支持 sbom
          build-args: |
            BUILD_DATE=${{ github.event.head_commit.timestamp }}
            VCS_REF=${{ github.sha }}
            VERSION=${{ github.ref_name }}
      
      - name: 📝 Set output
        id: set_output
        run: |
          # 使用 branch 名称作为默认标签
          echo "image_tag=${{ github.ref_name }}" >> $GITHUB_OUTPUT

  # 部署到测试服务器
  deploy:
    name: 部署到测试服务器
    runs-on: ubuntu-latest
    needs: build
    
    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4
      
      - name: 🔑 Setup SSH
        uses: webfactory/ssh-agent@v0.8.0
        with:
          ssh-private-key: ${{ secrets.TEST_SSH_PRIVATE_KEY }}
          
      - name: 📝 Add server to known hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.TEST_SERVER_HOST }} >> ~/.ssh/known_hosts
      
      - name: 🚀 Deploy to test server
        env:
          ACR_REGISTRY: ${{ secrets.ACR_REGISTRY }}
          ACR_NAMESPACE: ${{ secrets.ACR_NAMESPACE }}
          ACR_USERNAME: ${{ secrets.ACR_USERNAME }}
          ACR_PASSWORD: ${{ secrets.ACR_PASSWORD }}
          IMAGE_TAG: ${{ needs.build.outputs.image_tag }}
          ACR_CONFIGURED: ${{ needs.build.outputs.acr_configured }}
        run: |
          # 将部署脚本复制到服务器并执行
          ssh -o ServerAliveInterval=60 -o ServerAliveCountMax=3 -o ConnectTimeout=30 \
            ${{ secrets.TEST_SERVER_USER }}@${{ secrets.TEST_SERVER_HOST }} \
            "ACR_REGISTRY='${ACR_REGISTRY}' ACR_NAMESPACE='${ACR_NAMESPACE}' ACR_USERNAME='${ACR_USERNAME}' ACR_PASSWORD='${ACR_PASSWORD}' IMAGE_TAG='${IMAGE_TAG}' ACR_CONFIGURED='${ACR_CONFIGURED}'" bash << 'DEPLOY_SCRIPT'
            set -e
            
            echo "🔄 开始部署到测试环境..."
            
            # 进入项目目录
            cd /opt/HiFate-bazi
            
            # 拉取最新代码（使用 Gitee，国内服务器访问更快）
            echo "📥 拉取最新代码..."
            # 如果 remote 是 GitHub，添加 Gitee 作为备用
            if ! git remote | grep -q gitee; then
              git remote add gitee https://gitee.com/zhoudengtang/hifate-prod.git || true
            fi
            # 强制从 Gitee 重置到最新代码
            git fetch gitee master --force 2>/dev/null && git checkout master && git reset --hard gitee/master || {
              git fetch origin master --force 2>/dev/null && git checkout master && git reset --hard origin/master || {
                echo "⚠️  Git 拉取失败，使用现有代码继续部署"
                git checkout master 2>/dev/null || true
              }
            }
            
            # 检查并设置镜像标签
            if [ "${ACR_CONFIGURED}" == "true" ] && [ -n "${ACR_REGISTRY}" ] && [ -n "${ACR_NAMESPACE}" ]; then
              FULL_IMAGE="${ACR_REGISTRY}/${ACR_NAMESPACE}/hifate-bazi:${IMAGE_TAG}"
              
              # 登录到阿里云容器镜像服务
              echo "🔐 登录到阿里云容器镜像服务..."
              echo "${ACR_PASSWORD}" | docker login ${ACR_REGISTRY} -u ${ACR_USERNAME} --password-stdin || {
                echo "⚠️  ACR 登录失败，将使用本地构建"
                FULL_IMAGE="hifate-bazi:latest"
              }
              
              # 拉取最新镜像
              if [ "${FULL_IMAGE}" != "hifate-bazi:latest" ]; then
                echo "📥 拉取最新镜像: ${FULL_IMAGE}..."
                if docker pull ${FULL_IMAGE} 2>&1; then
                  echo "✅ 镜像拉取成功"
                else
                  echo "⚠️  拉取 ${IMAGE_TAG} 标签失败，尝试 latest 标签"
                  FULL_IMAGE="${ACR_REGISTRY}/${ACR_NAMESPACE}/hifate-bazi:latest"
                  if docker pull ${FULL_IMAGE} 2>&1; then
                    echo "✅ 镜像拉取成功"
                  else
                    echo "⚠️  无法拉取远程镜像，将使用本地构建"
                    FULL_IMAGE="hifate-bazi:latest"
                  fi
                fi
              fi
            else
              echo "⚠️  ACR 未配置，使用本地构建"
              FULL_IMAGE="hifate-bazi:latest"
              
              # 本地构建镜像
              echo "🔨 本地构建镜像..."
              docker build -t hifate-bazi:latest . || {
                echo "❌ 本地构建失败"
                exit 1
              }
            fi
            
            echo "📦 使用镜像: ${FULL_IMAGE}"
            
            # 先启动 MySQL 和 Redis 服务（如果未运行）
            echo "🔧 确保 MySQL 和 Redis 服务运行..."
            docker compose -f docker-compose.yml -f docker-compose.prod.yml up -d mysql redis
            
            # 等待 MySQL 和 Redis 健康检查通过
            echo "⏳ 等待 MySQL 和 Redis 就绪..."
            MAX_WAIT=60
            WAIT_COUNT=0
            while [ $WAIT_COUNT -lt $MAX_WAIT ]; do
              if docker compose -f docker-compose.yml -f docker-compose.prod.yml ps mysql | grep -q "healthy" && \
                 docker compose -f docker-compose.yml -f docker-compose.prod.yml ps redis | grep -q "healthy"; then
                echo "✅ MySQL 和 Redis 已就绪"
                break
              fi
              WAIT_COUNT=$((WAIT_COUNT + 1))
              echo "⏳ 等待中... ($WAIT_COUNT/$MAX_WAIT)"
              sleep 2
            done
            
            # 只清理已停止的容器（零停机部署）
            echo "🧹 清理已停止的容器..."
            docker compose -f docker-compose.yml -f docker-compose.prod.yml rm -f web 2>/dev/null || true
            
            # 清理可能存在的同名僵尸容器
            CONTAINER_IDS=$(docker ps -a --filter "name=hifate-web" --filter "status=exited" --format "{{.ID}}" 2>/dev/null || true)
            if [ -n "$CONTAINER_IDS" ]; then
              echo "🧹 清理僵尸容器..."
              echo "$CONTAINER_IDS" | xargs -r docker rm -f 2>/dev/null || true
            fi
            
            # 设置环境变量并启动服务
            export DOCKER_IMAGE=${FULL_IMAGE}
            
            # 滚动更新（零停机部署）
            echo "🔄 滚动更新服务（零停机）..."
            docker compose -f docker-compose.yml -f docker-compose.prod.yml up -d --no-deps web
            
            # 等待新容器启动
            echo "⏳ 等待新容器启动..."
            sleep 20
            
            # 健康检查（增强重试机制）
            echo "🏥 健康检查..."
            MAX_RETRIES=10  # 增加重试次数
            RETRY_COUNT=0
            HEALTH_CHECK_PASSED=false
            
            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
              # 检查基本健康端点
              if curl -f -s http://localhost:8001/health > /dev/null 2>&1; then
                echo "✅ 基本健康检查通过"
                
                # 检查 API 端点（更详细的检查）
                if curl -f -s http://localhost:8001/api/v1/health > /dev/null 2>&1; then
                  echo "✅ API 健康检查通过"
                  HEALTH_CHECK_PASSED=true
                  break
                else
                  echo "⚠️  API 健康检查失败，但基本健康检查通过"
                  # 如果基本健康检查通过，也认为成功（向后兼容）
                  HEALTH_CHECK_PASSED=true
                  break
                fi
              fi
              
              RETRY_COUNT=$((RETRY_COUNT + 1))
              echo "⏳ 健康检查失败，重试 $RETRY_COUNT/$MAX_RETRIES..."
              
              # 显示容器状态和日志（帮助调试）
              if [ $RETRY_COUNT -eq 3 ] || [ $RETRY_COUNT -eq 6 ]; then
                echo "📋 容器状态："
                docker compose -f docker-compose.yml -f docker-compose.prod.yml ps web || true
                echo "📋 最近日志（最后 20 行）："
                docker compose -f docker-compose.yml -f docker-compose.prod.yml logs --tail=20 web || true
              fi
              
              sleep 5
            done
            
            if [ "$HEALTH_CHECK_PASSED" = true ]; then
              echo "✅ 测试环境部署成功！服务运行正常"
              
              # 更新其他微服务
              docker compose -f docker-compose.yml -f docker-compose.prod.yml up -d --no-deps bazi-analyzer 2>/dev/null || true
              sleep 5
              docker compose -f docker-compose.yml -f docker-compose.prod.yml up -d --no-deps fortune-analyzer 2>/dev/null || true
              sleep 5
              docker compose -f docker-compose.yml -f docker-compose.prod.yml up -d --no-deps rule-service 2>/dev/null || true
              
              echo "✅ 所有服务更新完成"
            else
              echo "❌ 测试环境部署失败！服务未响应"
              echo "📋 查看服务日志："
              docker compose -f docker-compose.yml -f docker-compose.prod.yml logs --tail=100 web
              echo "📋 查看容器状态："
              docker compose -f docker-compose.yml -f docker-compose.prod.yml ps
              
              # 自动回滚到上一个版本
              echo "🔄 开始自动回滚..."
              
              # 检查是否有上一个版本的镜像
              if [ "${ACR_CONFIGURED}" == "true" ] && [ -n "${ACR_REGISTRY}" ] && [ -n "${ACR_NAMESPACE}" ]; then
                IMAGE_BASE="${ACR_REGISTRY}/${ACR_NAMESPACE}/hifate-bazi"
                
                # 尝试拉取 latest 标签（通常是上一个稳定版本）
                echo "📥 尝试回滚到 latest 标签..."
                ROLLBACK_IMAGE="${IMAGE_BASE}:latest"
                
                if docker pull ${ROLLBACK_IMAGE} 2>/dev/null; then
                  echo "✅ 找到回滚镜像: ${ROLLBACK_IMAGE}"
                  
                  # 清理已停止的容器
                  echo "🧹 清理已停止的容器..."
                  docker compose -f docker-compose.yml -f docker-compose.prod.yml rm -f web 2>/dev/null || true
                  CONTAINER_IDS=$(docker ps -a --filter "name=hifate-web" --filter "status=exited" --format "{{.ID}}" 2>/dev/null || true)
                  if [ -n "$CONTAINER_IDS" ]; then
                    echo "$CONTAINER_IDS" | xargs -r docker rm -f 2>/dev/null || true
                  fi
                  
                  # 使用回滚镜像启动服务
                  echo "🔄 使用回滚镜像启动服务..."
                  DOCKER_IMAGE=${ROLLBACK_IMAGE} docker compose -f docker-compose.yml -f docker-compose.prod.yml up -d --no-deps web
                  
                  # 等待回滚后的服务启动
                  echo "⏳ 等待回滚后的服务启动..."
                  sleep 15
                  
                  # 验证回滚后的服务
                  ROLLBACK_RETRIES=5
                  ROLLBACK_RETRY=0
                  ROLLBACK_SUCCESS=false
                  
                  while [ $ROLLBACK_RETRY -lt $ROLLBACK_RETRIES ]; do
                    if curl -f -s http://localhost:8001/health > /dev/null 2>&1; then
                      ROLLBACK_SUCCESS=true
                      echo "✅ 回滚成功！服务已恢复"
                      break
                    fi
                    ROLLBACK_RETRY=$((ROLLBACK_RETRY + 1))
                    echo "⏳ 回滚后健康检查，重试 $ROLLBACK_RETRY/$ROLLBACK_RETRIES..."
                    sleep 5
                  done
                  
                  if [ "$ROLLBACK_SUCCESS" = true ]; then
                    echo "✅ 回滚完成，服务已恢复到上一个版本"
                    exit 0  # 回滚成功，退出码为 0
                  else
                    echo "❌ 回滚失败，服务仍无法启动"
                    echo "请手动检查服务状态或联系管理员"
                    exit 1
                  fi
                else
                  echo "⚠️  无法找到回滚镜像，无法自动回滚"
                  echo "请手动检查服务状态或联系管理员"
                  exit 1
                fi
              else
                echo "⚠️  ACR 未配置，无法自动回滚"
                echo "请手动检查服务状态或联系管理员"
                exit 1
              fi
            fi
            
            # 清理未使用的镜像
            echo "🧹 清理旧镜像..."
            docker image prune -f
            
            echo "🎉 测试环境部署完成！"
          DEPLOY_SCRIPT
      
      - name: 📊 Deployment summary
        if: success()
        run: |
          echo "=========================================="
          echo "🎉 测试环境部署成功！"
          echo "=========================================="
          echo "环境：测试环境 (Test)"
          echo "服务器：${{ secrets.TEST_SERVER_HOST }}"
          echo "分支：master"
          echo "提交：${{ github.sha }}"
          echo "提交者：${{ github.actor }}"
          echo "访问：http://${{ secrets.TEST_SERVER_HOST }}:8001"
          echo "=========================================="